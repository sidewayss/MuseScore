//=============================================================================
//  MuseScore
//  Music Composition & Notation
//
//  Copyright (C) 2002-2014 Werner Schweer
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License version 2
//  as published by the Free Software Foundation and appearing in
//  the file LICENCE.GPL
//=============================================================================

/**
 File handling: loading and saving.
 */

#include "config.h"
#include "globals.h"
#include "musescore.h"
#include "scoreview.h"
#include "exportmidi.h"
#include "libmscore/xml.h"
#include "libmscore/element.h"
#include "libmscore/note.h"
#include "libmscore/rest.h"
#include "libmscore/sig.h"
#include "libmscore/clef.h"
#include "libmscore/key.h"
#include "instrdialog.h"
#include "libmscore/score.h"
#include "libmscore/page.h"
#include "libmscore/dynamic.h"
#include "file.h"
#include "libmscore/style.h"
#include "libmscore/tempo.h"
#include "libmscore/select.h"
#include "preferences.h"
#include "playpanel.h"
#include "libmscore/staff.h"
#include "libmscore/part.h"
#include "libmscore/utils.h"
#include "libmscore/barline.h"
#include "palette.h"
#include "symboldialog.h"
#include "libmscore/slur.h"
#include "libmscore/hairpin.h"
#include "libmscore/ottava.h"
#include "libmscore/textline.h"
#include "libmscore/pedal.h"
#include "libmscore/trill.h"
#include "libmscore/volta.h"
#include "newwizard.h"
#include "libmscore/timesig.h"
#include "libmscore/box.h"
#include "libmscore/excerpt.h"
#include "libmscore/system.h"
#include "libmscore/tuplet.h"
#include "libmscore/keysig.h"
#include "magbox.h"
#include "libmscore/measure.h"
#include "libmscore/undo.h"
#include "libmscore/repeatlist.h"
#include "scoretab.h"
#include "libmscore/beam.h"
#include "libmscore/stafftype.h"
#include "seq.h"
#include "libmscore/revisions.h"
#include "libmscore/lyrics.h"
#include "libmscore/segment.h"
#include "libmscore/tempotext.h"
#include "libmscore/sym.h"
#include "libmscore/image.h"
#include "synthesizer/msynthesizer.h"
#include "svggenerator.h"
#include "scorePreview.h"

#ifdef OMR
#include "omr/omr.h"
#include "omr/omrpage.h"
#include "omr/importpdf.h"
#endif

#include "diff/diff_match_patch.h"
#include "libmscore/chordlist.h"
#include "libmscore/mscore.h"
#include "thirdparty/qzip/qzipreader_p.h"

//////////////////////////////////
// SMAWS/MAB includes and defines
#include "libmscore/tie.h"
#include "libmscore/tempo.h"
#include "libmscore/chord.h"
#include "libmscore/iname.h"
#include "libmscore/notedot.h"
#include "libmscore/accidental.h"
#include "libmscore/instrchange.h"

// For QFileDialog. See MuseScore::exportFile() below
#define EXT_SVG  ".svg"
#define EXT_VTT  ".vtt"
#define EXT_HTML ".html"
#define EXT_JS   ".js"

#define FILE_DRUM_DEFS  "SMAWS_DrumDefs.svg.txt"
#define FILE_DRUM_BUTTS "SMAWS_DrumButts.svg.txt"
#define FILE_PAGE_BUTTS "SMAWS_DrumPageButts.svg.txt"

#define FILTER_SMAWS        "SMAWS SVG+VTT"
#define FILTER_SMAWS_MULTI  "SMAWS Multi-Staff"
#define FILTER_SMAWS_RULERS "SMAWS Rulers"
#define FILTER_SMAWS_TABLES "SMAWS HTML Tables"
#define FILTER_SMAWS_DRUMS  "SMAWS SVG Tables"
#define FILTER_MIX_TREE     "MAB MixTree VTT"

#define SMAWS_DESC_STUB "&#x00A9;%1 ~ sidewayss.com, generated by MuseScore %2 + SMAWS %3"

// For Cue ID formatting
#define CUE_ID_FIELD_WIDTH  7

// For Frozen Pane formatting
#define WIDTH_CLEF     16
#define WIDTH_KEY_SIG   5
#define WIDTH_TIME_SIG 10
#define X_OFF_TIME_SIG  3

// SMAWS/MAB end
//////////////////////////////////


namespace Ms {

extern void importSoundfont(QString name);
extern bool savePositions(Score*, const QString& name, bool segments);
extern MasterSynthesizer* synti;

//---------------------------------------------------------
//   paintElement(s)
//---------------------------------------------------------

static void paintElement(QPainter& p, const Element* e)
      {
      QPointF pos(e->pagePos());
      p.translate(pos);
      e->draw(&p);
      p.translate(-pos);
      }

static void paintElements(QPainter& p, const QList<Element*>& el)
      {
      for (Element* e : el) {
            if (!e->visible())
                  continue;
            paintElement(p, e);
            }
      }

//---------------------------------------------------------
//   createDefaultFileName
//---------------------------------------------------------

static QString createDefaultFileName(QString fn)
      {
      //
      // special characters in filenames are a constant source
      // of trouble, this replaces some of them common in german:
      //
      fn = fn.simplified();
      fn = fn.replace(QChar(' '),  "_");
      fn = fn.replace(QChar('\n'), "_");
      fn = fn.replace(QChar(0xe4), "ae");
      fn = fn.replace(QChar(0xf6), "oe");
      fn = fn.replace(QChar(0xfc), "ue");
      fn = fn.replace(QChar(0xdf), "ss");
      fn = fn.replace(QChar(0xc4), "Ae");
      fn = fn.replace(QChar(0xd6), "Oe");
      fn = fn.replace(QChar(0xdc), "Ue");
      fn = fn.replace( QRegExp( "[" + QRegExp::escape( "\\/:*?\"<>|" ) + "]" ), "_" ); //FAT/NTFS special chars
      return fn;
      }

//---------------------------------------------------------
//   readScoreError
//    if "ask" is true, ask to ignore; returns true if
//    ignore is pressed by user
//---------------------------------------------------------

static bool readScoreError(const QString& name, Score::FileError error, bool ask)
      {
      QString msg = QObject::tr("Cannot read file %1:\n").arg(name);
      QString detailedMsg;
      bool canIgnore = false;
      switch(error) {
            case Score::FileError::FILE_NO_ERROR:
                  return false;
            case Score::FileError::FILE_BAD_FORMAT:
                  msg +=  QObject::tr("bad format");
                  detailedMsg = MScore::lastError;
                  break;
            case Score::FileError::FILE_UNKNOWN_TYPE:
                  msg += QObject::tr("unknown type");
                  break;
            case Score::FileError::FILE_NO_ROOTFILE:
                  break;
            case Score::FileError::FILE_TOO_OLD:
                  msg += QObject::tr("It was last saved with version 0.9.5 or older.<br>"
                         "You can convert this score by opening and then saving with"
                         " MuseScore version 1.x</a>");
                  canIgnore = true;
                  break;
            case Score::FileError::FILE_TOO_NEW:
                  msg += QObject::tr("This score was saved using a newer version of MuseScore.<br>\n"
                         "Visit the <a href=\"http://musescore.org\">MuseScore website</a>"
                         " to obtain the latest version.");
                  canIgnore = true;
                  break;
            case Score::FileError::FILE_NOT_FOUND:
                  msg = QObject::tr("File not found %1").arg(name);
                  break;
            case Score::FileError::FILE_CORRUPTED:
                  msg = QObject::tr("File corrupted %1").arg(name);
                  detailedMsg = MScore::lastError;
                  canIgnore = true;
                  break;
            case Score::FileError::FILE_ERROR:
            case Score::FileError::FILE_OPEN_ERROR:
            default:
                  msg += MScore::lastError;
                  break;
            }
      int rv = false;
      if (converterMode || pluginMode) {
            fprintf(stderr, "%s\n", qPrintable(msg));
            return rv;
            }
      QMessageBox msgBox;
      msgBox.setWindowTitle(QObject::tr("MuseScore: Load Error"));
      msgBox.setText(msg);
      msgBox.setDetailedText(detailedMsg);
      msgBox.setTextFormat(Qt::RichText);
      if (canIgnore && ask)  {
            msgBox.setIcon(QMessageBox::Warning);
            msgBox.setStandardButtons(
               QMessageBox::Cancel | QMessageBox::Ignore
               );
            return msgBox.exec() == QMessageBox::Ignore;
            }
      else {
            msgBox.setIcon(QMessageBox::Critical);
            msgBox.setStandardButtons(
               QMessageBox::Ok
               );
            msgBox.exec();
            }
      return rv;
      }

//---------------------------------------------------------
//   checkDirty
//    if dirty, save score
//    return true on cancel
//---------------------------------------------------------

bool MuseScore::checkDirty(Score* s)
      {
      if (s->dirty() || s->created()) {
            QMessageBox::StandardButton n = QMessageBox::warning(this, tr("MuseScore"),
               tr("Save changes to the score \"%1\"\n"
               "before closing?").arg(s->fileInfo()->completeBaseName()),
               QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel,
               QMessageBox::Save);
            if (n == QMessageBox::Save) {
                  if (s->masterScore()->isSavable()) {
                        if (!saveFile(s))
                              return true;
                        }
                  else {
                        if (!saveAs(s, false))
                              return true;
                        }

                  }
            else if (n == QMessageBox::Cancel)
                  return true;
            }
      return false;
      }

//---------------------------------------------------------
//   loadFile
//---------------------------------------------------------

/**
 Create a modal file open dialog.
 If a file is selected, load it.
 Handles the GUI's file-open action.
 */

void MuseScore::loadFiles()
      {
      QStringList files = getOpenScoreNames(
#ifdef OMR
         tr("All Supported Files (*.mscz *.mscx *.xml *.mxl *.mid *.midi *.kar *.md *.mgu *.MGU *.sgu *.SGU *.cap *.capx *.pdf *.ove *.scw *.bww *.GTP *.GP3 *.GP4 *.GP5 *.GPX);;")+
#else
         tr("All Supported Files (*.mscz *.mscx *.xml *.mxl *.mid *.midi *.kar *.md *.mgu *.MGU *.sgu *.SGU *.cap *.capx *.ove *.scw *.bww *.GTP *.GP3 *.GP4 *.GP5 *.GPX);;")+
#endif
         tr("MuseScore Files (*.mscz *.mscx);;")+
         tr("MusicXML Files (*.xml *.mxl);;")+
         tr("MIDI Files (*.mid *.midi *.kar);;")+
         tr("Muse Data Files (*.md);;")+
         tr("Capella Files (*.cap *.capx);;")+
         tr("BB Files <experimental> (*.mgu *.MGU *.sgu *.SGU);;")+
#ifdef OMR
         tr("PDF Files <experimental OMR> (*.pdf);;")+
#endif
         tr("Overture / Score Writer Files <experimental> (*.ove *.scw);;")+
         tr("Bagpipe Music Writer Files <experimental> (*.bww);;")+
         tr("Guitar Pro (*.GTP *.GP3 *.GP4 *.GP5 *.GPX)"),
         tr("MuseScore: Load Score")
         );
      for (const QString& s : files)
            openScore(s);
      }

//---------------------------------------------------------
//   openScore
//---------------------------------------------------------

Score* MuseScore::openScore(const QString& fn)
      {
      //
      // make sure we load a file only once
      //
      QFileInfo fi(fn);
      QString path = fi.canonicalFilePath();
      for (Score* s : scoreList) {
            if (s->masterScore()->fileInfo()->canonicalFilePath() == path)
                  return 0;
            }

      MasterScore* score = readScore(fn);
      if (score) {
            setCurrentScoreView(appendScore(score));
            writeSessionFile(false);
            }
      return score;
      }

//---------------------------------------------------------
//   readScore
//---------------------------------------------------------

MasterScore* MuseScore::readScore(const QString& name)
      {
      if (name.isEmpty())
            return 0;

      MasterScore* score = new MasterScore(MScore::baseStyle());  // start with built-in style
      setMidiReopenInProgress(name);
      Score::FileError rv = Ms::readScore(score, name, false);
      if (rv == Score::FileError::FILE_TOO_OLD || rv == Score::FileError::FILE_TOO_NEW || rv == Score::FileError::FILE_CORRUPTED) {
            if (readScoreError(name, rv, true)) {
                  if (rv != Score::FileError::FILE_CORRUPTED) {
                        // dont read file again if corrupted
                        // the check routine may try to fix it
                        delete score;
                        score = new MasterScore(MScore::baseStyle());
                        rv = Ms::readScore(score, name, true);
                        }
                  else
                        rv = Score::FileError::FILE_NO_ERROR;
                  }
            else {
                  delete score;
                  return 0;
                  }
            }
      if (rv != Score::FileError::FILE_NO_ERROR) {
            // in case of user abort while reading, the error has already been reported
            // else report it now
            if (rv != Score::FileError::FILE_USER_ABORT && rv != Score::FileError::FILE_IGNORE_ERROR)
                  readScoreError(name, rv, false);
            delete score;
            score = 0;
            return 0;
            }
      allowShowMidiPanel(name);
      if (score)
            addRecentScore(score);
      return score;
      }

//---------------------------------------------------------
//   saveFile
///   Save the current score.
///   Handles the GUI's file-save action.
//
//    return true on success
//---------------------------------------------------------

bool MuseScore::saveFile()
      {
      return saveFile(cs->masterScore());
      }

//---------------------------------------------------------
//   saveFile
///   Save the score.
//
//    return true on success
//---------------------------------------------------------

bool MuseScore::saveFile(Score* score)
      {
      if (score == 0)
            return false;
      if (score->created()) {
            QString fn = score->masterScore()->fileInfo()->fileName();
            Text* t = score->getText(TextStyleType::TITLE);
            if (t)
                  fn = t->plainText(true);
            QString name = createDefaultFileName(fn);
            QString f1 = tr("MuseScore File (*.mscz)");
            QString f2 = tr("Uncompressed MuseScore File (*.mscx)");

            QSettings settings;
            if (mscore->lastSaveDirectory.isEmpty())
                  mscore->lastSaveDirectory = settings.value("lastSaveDirectory", preferences.myScoresPath).toString();
            QString saveDirectory = mscore->lastSaveDirectory;

            if (saveDirectory.isEmpty())
                  saveDirectory = preferences.myScoresPath;

            QString fname = QString("%1/%2").arg(saveDirectory).arg(name);
            QString filter = f1 + ";;" + f2;
            if (QFileInfo(fname).suffix().isEmpty())
                  fname += ".mscz";

            fn = mscore->getSaveScoreName(tr("MuseScore: Save Score"), fname, filter);
            if (fn.isEmpty())
                  return false;
            score->masterScore()->fileInfo()->setFile(fn);

            mscore->lastSaveDirectory = score->masterScore()->fileInfo()->absolutePath();

            if (!score->masterScore()->saveFile()) {
                  QMessageBox::critical(mscore, tr("MuseScore: Save File"), MScore::lastError);
                  return false;
                  }
            addRecentScore(score);
            writeSessionFile(false);
            }
      else if (!score->masterScore()->saveFile()) {
            QMessageBox::critical(mscore, tr("MuseScore: Save File"), MScore::lastError);
            return false;
            }
      score->setCreated(false);
      setWindowTitle("MuseScore: " + score->fileInfo()->completeBaseName());
      int idx = scoreList.indexOf(score->masterScore());
      tab1->setTabText(idx, score->fileInfo()->completeBaseName());
      if (tab2)
            tab2->setTabText(idx, score->fileInfo()->completeBaseName());
      QString tmp = score->tmpName();
      if (!tmp.isEmpty()) {
            QFile f(tmp);
            if (!f.remove())
                  qDebug("cannot remove temporary file <%s>", qPrintable(f.fileName()));
            score->setTmpName("");
            }
      writeSessionFile(false);
      return true;
      }

//---------------------------------------------------------
//   createDefaultName
//---------------------------------------------------------

QString MuseScore::createDefaultName() const
      {
      QString name(tr("Untitled"));
      int n;
      for (n = 1; ; ++n) {
            bool nameExists = false;
            QString tmpName;
            if (n == 1)
                  tmpName = name;
            else
                  tmpName = QString("%1-%2").arg(name).arg(n);
            foreach(Score* s, scoreList) {
                  if (s->fileInfo()->completeBaseName() == tmpName) {
                        nameExists = true;
                        break;
                        }
                  }
            if (!nameExists) {
                  name = tmpName;
                  break;
                  }
            }
      return name;
      }


void MuseScore::updateNewWizard()
      {
      if (newWizard != 0)
            newWizard = new NewWizard(this);
      }

//---------------------------------------------------------
//   newFile
//    create new score
//---------------------------------------------------------

void MuseScore::newFile()
      {
      if (newWizard == 0)
            newWizard = new NewWizard(this);
      newWizard->restart();
      if (newWizard->exec() != QDialog::Accepted)
            return;
      int measures            = newWizard->measures();
      Fraction timesig        = newWizard->timesig();
      TimeSigType timesigType = newWizard->timesigType();
      KeySigEvent ks          = newWizard->keysig();
      VBox* nvb               = nullptr;

      int pickupTimesigZ;
      int pickupTimesigN;
      bool pickupMeasure = newWizard->pickupMeasure(&pickupTimesigZ, &pickupTimesigN);
      if (pickupMeasure)
            measures += 1;

      MasterScore* score;
      QString tp = newWizard->templatePath();

      QList<Excerpt*> excerpts;
      if (!newWizard->emptyScore()) {
            MasterScore* tscore = new MasterScore(MScore::defaultStyle());
            Score::FileError rv = Ms::readScore(tscore, tp, false);
            if (rv != Score::FileError::FILE_NO_ERROR) {
                  readScoreError(newWizard->templatePath(), rv, false);
                  delete tscore;
                  return;
                  }
            score = new MasterScore(tscore->style());
            // create instruments from template
            for (Part* tpart : tscore->parts()) {
                  Part* part = new Part(score);
                  part->setInstrument(tpart->instrument());
                  part->setPartName(tpart->partName());

                  for (Staff* tstaff : *tpart->staves()) {
                        Staff* staff = new Staff(score);
                        staff->setPart(part);
                        staff->init(tstaff);
                        if (tstaff->linkedStaves() && !part->staves()->isEmpty()) {
                              Staff* linkedStaff = part->staves()->back();
                              staff->linkTo(linkedStaff);
                              }
                        part->insertStaff(staff, -1);
                        score->staves().append(staff);
                        }
                  score->appendPart(part);
                  }
            for (Excerpt* ex : tscore->excerpts()) {
                  Excerpt* x = new Excerpt(score);
                  x->setTitle(ex->title());
                  for (Part* p : ex->parts()) {
                        int pidx = tscore->parts().indexOf(p);
                        if (pidx == -1)
                              qDebug("newFile: part not found");
                        else
                              x->parts().append(score->parts()[pidx]);
                        }
                  excerpts.append(x);
                  }
            MeasureBase* mb = tscore->first();
            if (mb && mb->type() == Element::Type::VBOX) {
                  VBox* tvb = static_cast<VBox*>(mb);
                  nvb = new VBox(score);
                  nvb->setBoxHeight(tvb->boxHeight());
                  nvb->setBoxWidth(tvb->boxWidth());
                  nvb->setTopGap(tvb->topGap());
                  nvb->setBottomGap(tvb->bottomGap());
                  nvb->setTopMargin(tvb->topMargin());
                  nvb->setBottomMargin(tvb->bottomMargin());
                  nvb->setLeftMargin(tvb->leftMargin());
                  nvb->setRightMargin(tvb->rightMargin());
                  }
            delete tscore;
            }
      else {
            score = new MasterScore(MScore::defaultStyle());
            newWizard->createInstruments(score);
            }
      score->setCreated(true);
      score->masterScore()->fileInfo()->setFile(createDefaultName());

      if (!score->style()->chordList()->loaded()) {
            if (score->style()->value(StyleIdx::chordsXmlFile).toBool())
                  score->style()->chordList()->read("chords.xml");
            score->style()->chordList()->read(score->style()->value(StyleIdx::chordDescriptionFile).toString());
            }
      if (!newWizard->title().isEmpty())
            score->masterScore()->fileInfo()->setFile(newWizard->title());

      score->sigmap()->add(0, timesig);

      int firstMeasureTicks = pickupMeasure ? Fraction(pickupTimesigZ, pickupTimesigN).ticks() : timesig.ticks();

      for (int i = 0; i < measures; ++i) {
            int tick = firstMeasureTicks + timesig.ticks() * (i - 1);
            if (i == 0)
                  tick = 0;
            QList<Rest*> puRests;
            for (Score* _score : score->scoreList()) {
                  Rest* rest = 0;
                  Measure* measure = new Measure(_score);
                  measure->setTimesig(timesig);
                  measure->setLen(timesig);
                  measure->setTick(tick);

                  if (pickupMeasure && tick == 0) {
                        measure->setIrregular(true);        // dont count pickup measure
                        measure->setLen(Fraction(pickupTimesigZ, pickupTimesigN));
                        }
                  _score->measures()->add(measure);

                  for (Staff* staff : _score->staves()) {
                        int staffIdx = staff->idx();
                        if (tick == 0) {
                              TimeSig* ts = new TimeSig(_score);
                              ts->setTrack(staffIdx * VOICES);
                              ts->setSig(timesig, timesigType);
                              Measure* m = _score->firstMeasure();
                              Segment* s = m->getSegment(ts, 0);
                              s->add(ts);
                              Part* part = staff->part();
                              if (!part->instrument()->useDrumset()) {
                                    //
                                    // transpose key
                                    //
                                    KeySigEvent nKey = ks;
                                    if (!nKey.custom() && !nKey.isAtonal() && part->instrument()->transpose().chromatic && !score->styleB(StyleIdx::concertPitch)) {
                                          int diff = -part->instrument()->transpose().chromatic;
                                          nKey.setKey(transposeKey(nKey.key(), diff));
                                          }
                                    // do not create empty keysig unless custom or atonal
                                    if (nKey.custom() || nKey.isAtonal() || nKey.key() != Key::C) {
                                          staff->setKey(0, nKey);
                                          KeySig* keysig = new KeySig(score);
                                          keysig->setTrack(staffIdx * VOICES);
                                          keysig->setKeySigEvent(nKey);
                                          Segment* s = measure->getSegment(keysig, 0);
                                          s->add(keysig);
                                          }
                                    }
                              }

                        // determined if this staff is linked to previous so we can reuse rests
                        bool linkedToPrevious = staffIdx && staff->isLinked(_score->staff(staffIdx - 1));
                        if (measure->timesig() != measure->len()) {
                              if (!linkedToPrevious)
                                    puRests.clear();
                              std::vector<TDuration> dList = toDurationList(measure->len(), false);
                              if (!dList.empty()) {
                                    int ltick = tick;
                                    int k = 0;
                                    foreach (TDuration d, dList) {
                                          if (k < puRests.count())
                                                rest = static_cast<Rest*>(puRests[k]->linkedClone());
                                          else {
                                                rest = new Rest(score, d);
                                                puRests.append(rest);
                                                }
                                          rest->setScore(_score);
                                          rest->setDuration(d.fraction());
                                          rest->setTrack(staffIdx * VOICES);
                                          Segment* seg = measure->getSegment(rest, ltick);
                                          seg->add(rest);
                                          ltick += rest->actualTicks();
                                          k++;
                                          }
                                    }
                              }
                        else {
                              if (linkedToPrevious && rest)
                                    rest = static_cast<Rest*>(rest->linkedClone());
                              else
                                    rest = new Rest(score, TDuration(TDuration::DurationType::V_MEASURE));
                              rest->setScore(_score);
                              rest->setDuration(measure->len());
                              rest->setTrack(staffIdx * VOICES);
                              Segment* seg = measure->getSegment(rest, tick);
                              seg->add(rest);
                              }
                        }
                  }
            }
//TODO      score->lastMeasure()->setEndBarLineType(BarLineType::END, false);

      //
      // select first rest
      //
      Measure* m = score->firstMeasure();
      for (Segment* s = m->first(); s; s = s->next()) {
            if (s->segmentType() == Segment::Type::ChordRest) {
                  if (s->element(0)) {
                        score->select(s->element(0), SelectType::SINGLE, 0);
                        break;
                        }
                  }
            }

      QString title     = newWizard->title();
      QString subtitle  = newWizard->subtitle();
      QString composer  = newWizard->composer();
      QString poet      = newWizard->poet();
      QString copyright = newWizard->copyright();

      if (!title.isEmpty() || !subtitle.isEmpty() || !composer.isEmpty() || !poet.isEmpty()) {
            MeasureBase* measure = score->measures()->first();
            if (measure->type() != Element::Type::VBOX) {
                  MeasureBase* nm = nvb ? nvb : new VBox(score);
                  nm->setTick(0);
                  nm->setNext(measure);
                  score->measures()->add(nm);
                  measure = nm;
                  }
            else if (nvb) {
                  delete nvb;
                  }
            if (!title.isEmpty()) {
                  Text* s = new Text(score);
                  s->setTextStyleType(TextStyleType::TITLE);
                  s->setPlainText(title);
                  measure->add(s);
                  score->setMetaTag("workTitle", title);
                  }
            if (!subtitle.isEmpty()) {
                  Text* s = new Text(score);
                  s->setTextStyleType(TextStyleType::SUBTITLE);
                  s->setPlainText(subtitle);
                  measure->add(s);
                  }
            if (!composer.isEmpty()) {
                  Text* s = new Text(score);
                  s->setTextStyleType(TextStyleType::COMPOSER);
                  s->setPlainText(composer);
                  measure->add(s);
                  score->setMetaTag("composer", composer);
                  }
            if (!poet.isEmpty()) {
                  Text* s = new Text(score);
                  s->setTextStyleType(TextStyleType::POET);
                  s->setPlainText(poet);
                  measure->add(s);
                  // the poet() functions returns data called lyricist in the dialog
                  score->setMetaTag("lyricist", poet);
                  }
            }
      else if (nvb) {
            delete nvb;
            }

      if (newWizard->createTempo()) {
            double tempo = newWizard->tempo();
            TempoText* tt = new TempoText(score);
            tt->setXmlText(QString("<sym>metNoteQuarterUp</sym> = %1").arg(tempo));
            tempo /= 60;      // bpm -> bps

            tt->setTempo(tempo);
            tt->setFollowText(true);
            tt->setTrack(0);
            Segment* seg = score->firstMeasure()->first(Segment::Type::ChordRest);
            seg->add(tt);
            score->setTempo(0, tempo);
            }
      if (!copyright.isEmpty())
            score->setMetaTag("copyright", copyright);

      score->rebuildMidiMapping();
      score->doLayout();
      setCurrentScoreView(appendScore(score));

      for (Excerpt* x : excerpts) {
            Score* xs = new Score(static_cast<MasterScore*>(score));
            xs->setName(x->title());
            xs->style()->set(StyleIdx::createMultiMeasureRests, true);
            x->setPartScore(xs);
            score->excerpts().append(x);
            createExcerpt(x);
            score->setExcerptsChanged(true);
            }
      }

//---------------------------------------------------------
//   addScorePreview
//    add a score preview to the file dialog
//---------------------------------------------------------

static void addScorePreview(QFileDialog* dialog)
      {
      QSplitter* splitter = dialog->findChild<QSplitter*>("splitter");
      if (splitter) {
            ScorePreview* preview = new ScorePreview;
            splitter->addWidget(preview);
            dialog->connect(dialog, SIGNAL(currentChanged(const QString&)), preview, SLOT(setScore(const QString&)));
            }
      }

//---------------------------------------------------------
//   sidebarUrls
//    return a list of standard file dialog sidebar urls
//---------------------------------------------------------

static QList<QUrl> sidebarUrls()
      {
      QList<QUrl> urls;
      urls.append(QUrl::fromLocalFile(QDir::homePath()));
      QFileInfo myScores(preferences.myScoresPath);
      urls.append(QUrl::fromLocalFile(myScores.absoluteFilePath()));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));
      return urls;
      }

//---------------------------------------------------------
//   getOpenScoreNames
//---------------------------------------------------------

QStringList MuseScore::getOpenScoreNames(const QString& filter, const QString& title)
      {
      QSettings settings;
      QString dir = settings.value("lastOpenPath", preferences.myScoresPath).toString();
      if (preferences.nativeDialogs) {
            QStringList fileList = QFileDialog::getOpenFileNames(this,
               title, dir, filter);
            if (fileList.count() > 0) {
                  QFileInfo fi(fileList[0]);
                  settings.setValue("lastOpenPath", fi.absolutePath());
                  }
            return fileList;
            }
      QFileInfo myScores(preferences.myScoresPath);
      if (myScores.isRelative())
            myScores.setFile(QDir::home(), preferences.myScoresPath);

      if (loadScoreDialog == 0) {
            loadScoreDialog = new QFileDialog(this);
            loadScoreDialog->setFileMode(QFileDialog::ExistingFiles);
            loadScoreDialog->setOption(QFileDialog::DontUseNativeDialog, true);
            loadScoreDialog->setWindowTitle(title);
            addScorePreview(loadScoreDialog);

            // setup side bar urls
            QList<QUrl> urls = sidebarUrls();
            urls.append(QUrl::fromLocalFile(mscoreGlobalShare+"/demos"));
            loadScoreDialog->setSidebarUrls(urls);

            loadScoreDialog->setNameFilter(filter);
            restoreDialogState("loadScoreDialog", loadScoreDialog);
            loadScoreDialog->setAcceptMode(QFileDialog::AcceptOpen);
            loadScoreDialog->setDirectory(dir);
            }
      else {
            // dialog already exists, but set title and filter
            loadScoreDialog->setWindowTitle(title);
            loadScoreDialog->setNameFilter(filter);
            }

      QStringList result;
      if (loadScoreDialog->exec())
            result = loadScoreDialog->selectedFiles();
      settings.setValue("lastOpenPath", loadScoreDialog->directory().absolutePath());
      return result;
      }

//---------------------------------------------------------
//   getSaveScoreName
//---------------------------------------------------------

QString MuseScore::getSaveScoreName(const QString& title,
   QString& name, const QString& filter, bool selectFolder, QString* selectedFilter)
      {
      QFileInfo myName(name);
      if (myName.isRelative())
            myName.setFile(QDir::home(), name);
      name = myName.absoluteFilePath();

      if (preferences.nativeDialogs) {
            QString rv;
            QFileDialog dialog(this, title, myName.absolutePath(), filter);
            dialog.selectFile(myName.fileName());
            dialog.setAcceptMode(QFileDialog::AcceptSave);
            QFileDialog::Options options = selectFolder
                                         ? QFileDialog::ShowDirsOnly
                                         : QFileDialog::Options(0);
            dialog.setOptions(options);
            if(dialog.exec()) {
                rv = dialog.selectedFiles()[0];
                if (selectedFilter != 0)
                    *selectedFilter = dialog.selectedNameFilter();
                }
            return rv;
            }

      QFileInfo myScores(preferences.myScoresPath);
      if (myScores.isRelative())
            myScores.setFile(QDir::home(), preferences.myScoresPath);
      if (saveScoreDialog == 0) {
            saveScoreDialog = new QFileDialog(this);
            saveScoreDialog->setFileMode(QFileDialog::AnyFile);
            saveScoreDialog->setOption(QFileDialog::DontConfirmOverwrite, false);
            saveScoreDialog->setOption(QFileDialog::DontUseNativeDialog, true);
            saveScoreDialog->setAcceptMode(QFileDialog::AcceptSave);
            addScorePreview(saveScoreDialog);

            // setup side bar urls
            saveScoreDialog->setSidebarUrls(sidebarUrls());

            restoreDialogState("saveScoreDialog", saveScoreDialog);
            }
      if (selectFolder)
            saveScoreDialog->setFileMode(QFileDialog::Directory);

      saveScoreDialog->setWindowTitle(title);
      saveScoreDialog->setNameFilter(filter);
      saveScoreDialog->selectFile(name);

      if (!selectFolder) {
            connect(saveScoreDialog, SIGNAL(filterSelected(const QString&)),
               SLOT(saveScoreDialogFilterSelected(const QString&)));
            }
      QString s;
      if (saveScoreDialog->exec())
            s = saveScoreDialog->selectedFiles().front();
      return s;
      }

//---------------------------------------------------------
//   saveScoreDialogFilterSelected
//    update selected file name extensions, when filter
//    has changed
//---------------------------------------------------------

void MuseScore::saveScoreDialogFilterSelected(const QString& s)
      {
      QRegExp rx(QString(".+\\(\\*\\.(.+)\\)"));
      if (rx.exactMatch(s)) {
            QFileInfo fi(saveScoreDialog->selectedFiles().front());
            saveScoreDialog->selectFile(fi.completeBaseName() + "." + rx.cap(1));
            }
      }

//---------------------------------------------------------
//   getStyleFilename
//---------------------------------------------------------

QString MuseScore::getStyleFilename(bool open, const QString& title)
      {
      QFileInfo myStyles(preferences.myStylesPath);
      if (myStyles.isRelative())
            myStyles.setFile(QDir::home(), preferences.myStylesPath);
      QString defaultPath = myStyles.absoluteFilePath();

      if (preferences.nativeDialogs) {
            QString fn;
            if (open) {
                  fn = QFileDialog::getOpenFileName(
                     this, tr("MuseScore: Load Style"),
                     defaultPath,
                     tr("MuseScore Styles (*.mss)")
                     );
                  }
            else {
                  fn = QFileDialog::getSaveFileName(
                     this, tr("MuseScore: Save Style"),
                     defaultPath,
                     tr("MuseScore Style File (*.mss)")
                     );
                  }
            return fn;
            }

      QFileDialog* dialog;
      QList<QUrl> urls;
      QString home = QDir::homePath();
      urls.append(QUrl::fromLocalFile(home));
      urls.append(QUrl::fromLocalFile(defaultPath));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));

      if (open) {
            if (loadStyleDialog == 0) {
                  loadStyleDialog = new QFileDialog(this);
                  loadStyleDialog->setFileMode(QFileDialog::ExistingFile);
                  loadStyleDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  loadStyleDialog->setWindowTitle(title.isEmpty() ? tr("MuseScore: Load Style") : title);
                  loadStyleDialog->setNameFilter(tr("MuseScore Style File (*.mss)"));
                  loadStyleDialog->setDirectory(defaultPath);

                  restoreDialogState("loadStyleDialog", loadStyleDialog);
                  loadStyleDialog->setAcceptMode(QFileDialog::AcceptOpen);
                  }
            urls.append(QUrl::fromLocalFile(mscoreGlobalShare+"/styles"));
            dialog = loadStyleDialog;
            }
      else {
            if (saveStyleDialog == 0) {
                  saveStyleDialog = new QFileDialog(this);
                  saveStyleDialog->setAcceptMode(QFileDialog::AcceptSave);
                  saveStyleDialog->setFileMode(QFileDialog::AnyFile);
                  saveStyleDialog->setOption(QFileDialog::DontConfirmOverwrite, false);
                  saveStyleDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  saveStyleDialog->setWindowTitle(title.isEmpty() ? tr("MuseScore: Save Style") : title);
                  saveStyleDialog->setNameFilter(tr("MuseScore Style File (*.mss)"));
                  saveStyleDialog->setDirectory(defaultPath);

                  restoreDialogState("saveStyleDialog", saveStyleDialog);
                  saveStyleDialog->setAcceptMode(QFileDialog::AcceptSave);
                  }
            dialog = saveStyleDialog;
            }
      // setup side bar urls
      dialog->setSidebarUrls(urls);

      if (dialog->exec()) {
            QStringList result = dialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   getChordStyleFilename
//---------------------------------------------------------

QString MuseScore::getChordStyleFilename(bool open)
      {
      QString filter = tr("Chord Symbols Style File (*.xml)");

      QFileInfo myStyles(preferences.myStylesPath);
      if (myStyles.isRelative())
            myStyles.setFile(QDir::home(), preferences.myStylesPath);
      QString defaultPath = myStyles.absoluteFilePath();

      if (preferences.nativeDialogs) {
            QString fn;
            if (open) {
                  fn = QFileDialog::getOpenFileName(
                     this, tr("MuseScore: Load Chord Symbols Style"),
                     defaultPath,
                     filter
                     );
                  }
            else {
                  fn = QFileDialog::getSaveFileName(
                     this, tr("MuseScore: Save Chord Symbols Style"),
                     defaultPath,
                     filter
                     );
                  }
            return fn;
            }

      QFileDialog* dialog;
      QList<QUrl> urls;
      QString home = QDir::homePath();
      urls.append(QUrl::fromLocalFile(home));
      urls.append(QUrl::fromLocalFile(defaultPath));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));

      QSettings settings;
      if (open) {
            if (loadChordStyleDialog == 0) {
                  loadChordStyleDialog = new QFileDialog(this);
                  loadChordStyleDialog->setFileMode(QFileDialog::ExistingFile);
                  loadChordStyleDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  loadChordStyleDialog->setWindowTitle(tr("MuseScore: Load Chord Symbols Style"));
                  loadChordStyleDialog->setNameFilter(filter);
                  loadChordStyleDialog->setDirectory(defaultPath);

                  restoreDialogState("loadChordStyleDialog", loadChordStyleDialog);
                  loadChordStyleDialog->restoreState(settings.value("loadChordStyleDialog").toByteArray());
                  loadChordStyleDialog->setAcceptMode(QFileDialog::AcceptOpen);
                  }
            // setup side bar urls
            urls.append(QUrl::fromLocalFile(mscoreGlobalShare+"/styles"));
            dialog = loadChordStyleDialog;
            }
      else {
            if (saveChordStyleDialog == 0) {
                  saveChordStyleDialog = new QFileDialog(this);
                  saveChordStyleDialog->setAcceptMode(QFileDialog::AcceptSave);
                  saveChordStyleDialog->setFileMode(QFileDialog::AnyFile);
                  saveChordStyleDialog->setOption(QFileDialog::DontConfirmOverwrite, false);
                  saveChordStyleDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  saveChordStyleDialog->setWindowTitle(tr("MuseScore: Save Style"));
                  saveChordStyleDialog->setNameFilter(filter);
                  saveChordStyleDialog->setDirectory(defaultPath);

                  restoreDialogState("saveChordStyleDialog", saveChordStyleDialog);
                  saveChordStyleDialog->setAcceptMode(QFileDialog::AcceptSave);
                  }
            dialog = saveChordStyleDialog;
            }
      // setup side bar urls
      dialog->setSidebarUrls(urls);
      if (dialog->exec()) {
            QStringList result = dialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   getScanFile
//---------------------------------------------------------

QString MuseScore::getScanFile(const QString& d)
      {
      QString filter = tr("PDF Scan File (*.pdf);;All (*)");
      QString defaultPath = d.isEmpty() ? QDir::homePath() : d;
      if (preferences.nativeDialogs) {
            QString s = QFileDialog::getOpenFileName(
               mscore,
               MuseScore::tr("Choose PDF Scan"),
               defaultPath,
               filter
               );
            return s;
            }

      if (loadScanDialog == 0) {
            loadScanDialog = new QFileDialog(this);
            loadScanDialog->setFileMode(QFileDialog::ExistingFile);
            loadScanDialog->setOption(QFileDialog::DontUseNativeDialog, true);
            loadScanDialog->setWindowTitle(tr("MuseScore: Choose PDF Scan"));
            loadScanDialog->setNameFilter(filter);
            loadScanDialog->setDirectory(defaultPath);

            restoreDialogState("loadScanDialog", loadScanDialog);
            loadScanDialog->setAcceptMode(QFileDialog::AcceptOpen);
            }

      //
      // setup side bar urls
      //
      QList<QUrl> urls;
      QString home = QDir::homePath();
      urls.append(QUrl::fromLocalFile(home));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));
      loadScanDialog->setSidebarUrls(urls);

      if (loadScanDialog->exec()) {
            QStringList result = loadScanDialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   getAudioFile
//---------------------------------------------------------

QString MuseScore::getAudioFile(const QString& d)
      {
      QString filter = tr("Ogg Audio File (*.ogg);;All (*)");
      QString defaultPath = d.isEmpty() ? QDir::homePath() : d;
      if (preferences.nativeDialogs) {
            QString s = QFileDialog::getOpenFileName(
               mscore,
               MuseScore::tr("Choose Audio File"),
               defaultPath,
               filter
               );
            return s;
            }

      if (loadAudioDialog == 0) {
            loadAudioDialog = new QFileDialog(this);
            loadAudioDialog->setFileMode(QFileDialog::ExistingFile);
            loadAudioDialog->setOption(QFileDialog::DontUseNativeDialog, true);
            loadAudioDialog->setWindowTitle(tr("MuseScore: Choose Ogg Audio File"));
            loadAudioDialog->setNameFilter(filter);
            loadAudioDialog->setDirectory(defaultPath);

            restoreDialogState("loadAudioDialog", loadAudioDialog);
            loadAudioDialog->setAcceptMode(QFileDialog::AcceptOpen);
            }

      //
      // setup side bar urls
      //
      QList<QUrl> urls;
      QString home = QDir::homePath();
      urls.append(QUrl::fromLocalFile(home));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));
      loadAudioDialog->setSidebarUrls(urls);

      if (loadAudioDialog->exec()) {
            QStringList result = loadAudioDialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   getFotoFilename
//---------------------------------------------------------

QString MuseScore::getFotoFilename(QString& filter, QString* selectedFilter)
      {
      QString title = tr("MuseScore: Save Image");

      QFileInfo myImages(preferences.myImagesPath);
      if (myImages.isRelative())
            myImages.setFile(QDir::home(), preferences.myImagesPath);
      QString defaultPath = myImages.absoluteFilePath();

      if (preferences.nativeDialogs) {
            QString fn;
            fn = QFileDialog::getSaveFileName(
               this,
               title,
               defaultPath,
               filter,
               selectedFilter
               );
            return fn;
            }


      QList<QUrl> urls;
      urls.append(QUrl::fromLocalFile(QDir::homePath()));
      urls.append(QUrl::fromLocalFile(defaultPath));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));

      if (saveImageDialog == 0) {
            saveImageDialog = new QFileDialog(this);
            saveImageDialog->setFileMode(QFileDialog::AnyFile);
            saveImageDialog->setAcceptMode(QFileDialog::AcceptSave);
            saveImageDialog->setOption(QFileDialog::DontConfirmOverwrite, false);
            saveImageDialog->setOption(QFileDialog::DontUseNativeDialog, true);
            saveImageDialog->setWindowTitle(title);
            saveImageDialog->setNameFilter(filter);
            saveImageDialog->setDirectory(defaultPath);

            restoreDialogState("saveImageDialog", saveImageDialog);
            saveImageDialog->setAcceptMode(QFileDialog::AcceptSave);
            }

      // setup side bar urls
      saveImageDialog->setSidebarUrls(urls);

      if (saveImageDialog->exec()) {
            QStringList result = saveImageDialog->selectedFiles();
            *selectedFilter = saveImageDialog->selectedNameFilter();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   getPaletteFilename
//---------------------------------------------------------

QString MuseScore::getPaletteFilename(bool open, const QString& name)
      {
      QString title;
      QString filter;
      QString wd      = QString("%1/%2").arg(QDesktopServices::storageLocation(QDesktopServices::DocumentsLocation)).arg(QCoreApplication::applicationName());
      if (open) {
            title  = tr("MuseScore: Load Palette");
            filter = tr("MuseScore Palette (*.mpal)");
            }
      else {
            title  = tr("MuseScore: Save Palette");
            filter = tr("MuseScore Palette (*.mpal)");
            }

      QFileInfo myPalettes(wd);
      QString defaultPath = myPalettes.absoluteFilePath();
      if (!name.isEmpty()) {
            QString fname = createDefaultFileName(name);
            QFileInfo myName(fname);
            if (myName.isRelative())
                  myName.setFile(defaultPath, fname);
            defaultPath = myName.absoluteFilePath();
            }

      if (preferences.nativeDialogs) {
            QString fn;
            if (open)
                  fn = QFileDialog::getOpenFileName(this, title, defaultPath, filter);
            else
                  fn = QFileDialog::getSaveFileName(this, title, defaultPath, filter);
            return fn;
            }

      QFileDialog* dialog;
      QList<QUrl> urls;
      urls.append(QUrl::fromLocalFile(QDir::homePath()));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));
      urls.append(QUrl::fromLocalFile(defaultPath));

      if (open) {
            if (loadPaletteDialog == 0) {
                  loadPaletteDialog = new QFileDialog(this);
                  loadPaletteDialog->setFileMode(QFileDialog::ExistingFile);
                  loadPaletteDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  loadPaletteDialog->setDirectory(defaultPath);

                  restoreDialogState("loadPaletteDialog", loadPaletteDialog);
                  loadPaletteDialog->setAcceptMode(QFileDialog::AcceptOpen);
                  }
            urls.append(QUrl::fromLocalFile(mscoreGlobalShare+"/styles"));
            dialog = loadPaletteDialog;
            }
      else {
            if (savePaletteDialog == 0) {
                  savePaletteDialog = new QFileDialog(this);
                  savePaletteDialog->setAcceptMode(QFileDialog::AcceptSave);
                  savePaletteDialog->setFileMode(QFileDialog::AnyFile);
                  savePaletteDialog->setOption(QFileDialog::DontConfirmOverwrite, false);
                  savePaletteDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  savePaletteDialog->setDirectory(defaultPath);

                  restoreDialogState("savePaletteDialog", savePaletteDialog);
                  savePaletteDialog->setAcceptMode(QFileDialog::AcceptSave);
                  }
            dialog = savePaletteDialog;
            }
      dialog->setWindowTitle(title);
      dialog->setNameFilter(filter);

      // setup side bar urls
      dialog->setSidebarUrls(urls);

      if (dialog->exec()) {
            QStringList result = dialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   getPluginFilename
//---------------------------------------------------------

QString MuseScore::getPluginFilename(bool open)
      {
      QString title;
      QString filter;
      if (open) {
            title  = tr("MuseScore: Load Plugin");
            filter = tr("MuseScore Plugin (*.qml)");
            }
      else {
            title  = tr("MuseScore: Save Plugin");
            filter = tr("MuseScore Plugin File (*.qml)");
            }

      QFileInfo myPlugins(preferences.myPluginsPath);
      if (myPlugins.isRelative())
            myPlugins.setFile(QDir::home(), preferences.myPluginsPath);
      QString defaultPath = myPlugins.absoluteFilePath();

      QString name  = createDefaultFileName("Plugin");
      QString fname = QString("%1/%2.qml").arg(defaultPath).arg(name);
      if (preferences.nativeDialogs) {
            QString fn;
            if (open)
                  fn = QFileDialog::getOpenFileName(this, title, defaultPath, filter);
            else
                  fn = QFileDialog::getSaveFileName(this, title, defaultPath, filter);
            return fn;
            }

      QFileDialog* dialog;
      QList<QUrl> urls;
      QString home = QDir::homePath();
      urls.append(QUrl::fromLocalFile(home));
      urls.append(QUrl::fromLocalFile(defaultPath));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));

      if (open) {
            if (loadPluginDialog == 0) {
                  loadPluginDialog = new QFileDialog(this);
                  loadPluginDialog->setFileMode(QFileDialog::ExistingFile);
                  loadPluginDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  loadPluginDialog->setDirectory(defaultPath);

                  QSettings settings;
                  loadPluginDialog->restoreState(settings.value("loadPluginDialog").toByteArray());
                  loadPluginDialog->setAcceptMode(QFileDialog::AcceptOpen);
                  }
            urls.append(QUrl::fromLocalFile(mscoreGlobalShare+"/styles"));
            dialog = loadPluginDialog;
            }
      else {
            if (savePluginDialog == 0) {
                  savePluginDialog = new QFileDialog(this);
                  QSettings settings;
                  savePluginDialog->restoreState(settings.value("savePluginDialog").toByteArray());
                  savePluginDialog->setAcceptMode(QFileDialog::AcceptSave);
                  savePluginDialog->setFileMode(QFileDialog::AnyFile);
                  savePluginDialog->setOption(QFileDialog::DontConfirmOverwrite, false);
                  savePluginDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  savePluginDialog->setWindowTitle(tr("MuseScore: Save Plugin"));
                  savePluginDialog->setNameFilter(filter);
                  savePluginDialog->setDirectory(defaultPath);
                  savePluginDialog->selectFile(fname);
                  }
            dialog = savePluginDialog;
            }
      dialog->setWindowTitle(title);
      dialog->setNameFilter(filter);

      // setup side bar urls
      dialog->setSidebarUrls(urls);

      if (dialog->exec()) {
            QStringList result = dialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   getDrumsetFilename
//---------------------------------------------------------

QString MuseScore::getDrumsetFilename(bool open)
      {
      QString title;
      QString filter;
      if (open) {
            title  = tr("MuseScore: Load Drumset");
            filter = tr("MuseScore Drumset (*.drm)");
            }
      else {
            title  = tr("MuseScore: Save Drumset");
            filter = tr("MuseScore Drumset File (*.drm)");
            }

      QFileInfo myStyles(preferences.myStylesPath);
      if (myStyles.isRelative())
            myStyles.setFile(QDir::home(), preferences.myStylesPath);
      QString defaultPath  = myStyles.absoluteFilePath();

      if (preferences.nativeDialogs) {
            QString fn;
            if (open)
                  fn = QFileDialog::getOpenFileName(this, title, defaultPath, filter);
            else
                  fn = QFileDialog::getSaveFileName(this, title, defaultPath, filter);
            return fn;
            }


      QFileDialog* dialog;
      QList<QUrl> urls;
      QString home = QDir::homePath();
      urls.append(QUrl::fromLocalFile(home));
      urls.append(QUrl::fromLocalFile(defaultPath));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));

      if (open) {
            if (loadDrumsetDialog == 0) {
                  loadDrumsetDialog = new QFileDialog(this);
                  loadDrumsetDialog->setFileMode(QFileDialog::ExistingFile);
                  loadDrumsetDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  loadDrumsetDialog->setDirectory(defaultPath);

                  restoreDialogState("loadDrumsetDialog", loadDrumsetDialog);
                  loadDrumsetDialog->setAcceptMode(QFileDialog::AcceptOpen);
                  }
            urls.append(QUrl::fromLocalFile(mscoreGlobalShare+"/styles"));
            dialog = loadDrumsetDialog;
            }
      else {
            if (saveDrumsetDialog == 0) {
                  saveDrumsetDialog = new QFileDialog(this);
                  saveDrumsetDialog->setAcceptMode(QFileDialog::AcceptSave);
                  saveDrumsetDialog->setFileMode(QFileDialog::AnyFile);
                  saveDrumsetDialog->setOption(QFileDialog::DontConfirmOverwrite, false);
                  saveDrumsetDialog->setOption(QFileDialog::DontUseNativeDialog, true);
                  saveDrumsetDialog->setDirectory(defaultPath);

                  restoreDialogState("saveDrumsetDialog", saveDrumsetDialog);
                  saveDrumsetDialog->setAcceptMode(QFileDialog::AcceptSave);
                  }
            dialog = saveDrumsetDialog;
            }
      dialog->setWindowTitle(title);
      dialog->setNameFilter(filter);

      // setup side bar urls
      dialog->setSidebarUrls(urls);

      if (dialog->exec()) {
            QStringList result = dialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

//---------------------------------------------------------
//   printFile
//---------------------------------------------------------

void MuseScore::printFile()
      {
      QPrinter printerDev(QPrinter::HighResolution);
      const PageFormat* pf = cs->pageFormat();
      printerDev.setPaperSize(pf->size(), QPrinter::Inch);

      printerDev.setCreator("MuseScore Version: " VERSION);
      printerDev.setFullPage(true);
      if (!printerDev.setPageMargins(QMarginsF()))
            qDebug("unable to clear printer margins");
      printerDev.setColorMode(QPrinter::Color);
      printerDev.setDocName(cs->fileInfo()->completeBaseName());
      printerDev.setOutputFormat(QPrinter::NativeFormat);
      int pages    = cs->pages().size();
      printerDev.setFromTo(1, pages);

#if defined(Q_OS_MAC) || defined(Q_OS_WIN)
      printerDev.setOutputFileName("");
#else
      // when setting this on windows platform, pd.exec() does not
      // show dialog
      printerDev.setOutputFileName(cs->masterScore()->fileInfo()->path() + "/" + cs->fileInfo()->completeBaseName() + ".pdf");
#endif

      QPrintDialog pd(&printerDev, 0);

      if (!pd.exec())
            return;

      LayoutMode layoutMode = cs->layoutMode();
      cs->switchToPageMode();

      QPainter p(&printerDev);
      p.setRenderHint(QPainter::Antialiasing, true);
      p.setRenderHint(QPainter::TextAntialiasing, true);
      double mag = printerDev.logicalDpiX() / DPI;

      p.scale(mag, mag);

      int fromPage = printerDev.fromPage() - 1;
      int toPage   = printerDev.toPage() - 1;
      if (fromPage < 0)
            fromPage = 0;
      if ((toPage < 0) || (toPage >= pages))
            toPage = pages - 1;

      for (int copy = 0; copy < printerDev.numCopies(); ++copy) {
            bool firstPage = true;
            for (int n = fromPage; n <= toPage; ++n) {
                  if (!firstPage)
                        printerDev.newPage();
                  firstPage = false;

                  cs->print(&p, n);
                  if ((copy + 1) < printerDev.numCopies())
                        printerDev.newPage();
                  }
            }
      p.end();
      if (layoutMode != cs->layoutMode())
            cs->endCmd(true);       // rollback
      }

//---------------------------------------------------------
//   exportFile
//    return true on success
//---------------------------------------------------------

void MuseScore::exportFile()
      {
      QStringList fl;
      fl.append(tr("PDF File (*.pdf)"));
      fl.append(tr("PNG Bitmap Graphic (*.png)"));
      fl.append(tr("Scalable Vector Graphic (*%1)").arg(EXT_SVG));
#ifdef HAS_AUDIOFILE
      fl.append(tr("Wave Audio (*.wav)"));
      fl.append(tr("FLAC Audio (*.flac)"));
      fl.append(tr("Ogg Vorbis Audio (*.ogg)"));
#endif
#ifdef USE_LAME
      fl.append(tr("MP3 Audio (*.mp3)"));
#endif
      fl.append(tr("Standard MIDI File (*.mid)"));
      fl.append(tr("MusicXML File (*.xml)"));
      fl.append(tr("Compressed MusicXML File (*.mxl)"));
      fl.append(tr("Uncompressed MuseScore File (*.mscx)"));
// SMAWS/MAB options
      fl.append(tr("%1 (*%2)").arg(FILTER_SMAWS).arg(EXT_VTT));
      fl.append(tr("%1 (*%2)").arg(FILTER_SMAWS_MULTI).arg(EXT_VTT));
      fl.append(tr("%1 (*%2)").arg(FILTER_SMAWS_RULERS).arg(EXT_VTT));
      fl.append(tr("%1 (*%2)").arg(FILTER_SMAWS_DRUMS).arg(EXT_VTT));
      fl.append(tr("%1 (*%2)").arg(FILTER_SMAWS_TABLES).arg(EXT_VTT));
      fl.append(tr("%1 (*%2)").arg(FILTER_MIX_TREE).arg(EXT_VTT));
// SMAWS/MAB end

      QString saveDialogTitle = tr("MuseScore: Export");

      QSettings settings;
      if (lastSaveCopyDirectory.isEmpty())
            lastSaveCopyDirectory = settings.value("lastSaveCopyDirectory", preferences.myScoresPath).toString();
      if (lastSaveDirectory.isEmpty())
            lastSaveDirectory = settings.value("lastSaveDirectory", preferences.myScoresPath).toString();
      QString saveDirectory = lastSaveCopyDirectory;

      if (saveDirectory.isEmpty())
            saveDirectory = preferences.myScoresPath;

      if (lastSaveCopyFormat.isEmpty())
            lastSaveCopyFormat = settings.value("lastSaveCopyFormat", "pdf").toString();
      QString saveFormat = lastSaveCopyFormat;

      if (saveFormat.isEmpty())
            saveFormat = "pdf";

      QString name;
#ifdef Q_OS_WIN
      if (QSysInfo::WindowsVersion == QSysInfo::WV_XP) {
            if (!cs->isMaster())
                  name = QString("%1/%2-%3").arg(saveDirectory).arg(cs->masterScore()->fileInfo()->completeBaseName()).arg(createDefaultFileName(cs->name()));
            else
                  name = QString("%1/%2").arg(saveDirectory).arg(cs->fileInfo()->completeBaseName());
            }
      else
#endif
      if (!cs->isMaster())
            name = QString("%1/%2-%3.%4").arg(saveDirectory).arg(cs->masterScore()->fileInfo()->completeBaseName()).arg(createDefaultFileName(cs->fileInfo()->completeBaseName())).arg(saveFormat);
      else
            name = QString("%1/%2.%3").arg(saveDirectory).arg(cs->fileInfo()->completeBaseName()).arg(saveFormat);

      int idx = fl.indexOf(QRegExp(".+\\(\\*\\." + saveFormat + "\\)"), Qt::CaseInsensitive);
      if (idx != -1)
            fl.move(idx, 0);
      QString filter = fl.join(";;");
      QString selectedFilter;
      QString fn = getSaveScoreName(saveDialogTitle, name, filter, false, &selectedFilter);
      if (fn.isEmpty())
            return;

      QFileInfo fi(fn);
      lastSaveCopyDirectory = fi.absolutePath();
      lastSaveCopyFormat = fi.suffix();

      // SaveAs() is restrictive in a variety of ways, especially the lack of
      // selectedFilter. For SMAWS/MAB, this is all that's necessary:
      if (fn.right(4) == EXT_VTT) {
            cs->switchToPageMode();
            if (selectedFilter.contains(FILTER_SMAWS))
                  saveSMAWS(cs, &fi, false);
            else if (selectedFilter.contains(FILTER_SMAWS_MULTI))
                  saveSMAWS(cs, &fi, true);
            else if (selectedFilter.contains(FILTER_SMAWS_RULERS))
                  saveSMAWS_Rulers(cs, &fi);
            else if (selectedFilter.contains(FILTER_SMAWS_DRUMS))
                  saveSMAWS_Tables(cs, &fi, false);
            else if (selectedFilter.contains(FILTER_SMAWS_TABLES))
                  saveSMAWS_Tables(cs, &fi, true);
            else if (selectedFilter.contains(FILTER_MIX_TREE))
                  saveMAB_MixTree(cs, &fi);
      }

      else if (fi.suffix().isEmpty())
            QMessageBox::critical(this, tr("MuseScore: Export"), tr("Cannot determine file type"));

      else // Everything NOT SMAWS/MAB
            saveAs(cs, true, fn, lastSaveCopyFormat);
      }

//---------------------------------------------------------
//   exportParts
//    return true on success
//---------------------------------------------------------

bool MuseScore::exportParts()
      {
      QStringList fl;
      fl.append(tr("PDF File (*.pdf)"));
      fl.append(tr("PNG Bitmap Graphic (*.png)"));
      fl.append(tr("Scalable Vector Graphic (%1)").arg(EXT_SVG));
#ifdef HAS_AUDIOFILE
      fl.append(tr("Wave Audio (*.wav)"));
      fl.append(tr("FLAC Audio (*.flac)"));
      fl.append(tr("Ogg Vorbis Audio (*.ogg)"));
#endif
#ifdef USE_LAME
      fl.append(tr("MP3 Audio (*.mp3)"));
#endif
      fl.append(tr("Standard MIDI File (*.mid)"));
      fl.append(tr("MusicXML File (*.xml)"));
      fl.append(tr("Compressed MusicXML File (*.mxl)"));
      fl.append(tr("MuseScore File (*.mscz)"));
      fl.append(tr("Uncompressed MuseScore File (*.mscx)"));

      QString saveDialogTitle = tr("MuseScore: Export Parts");

      QSettings settings;
      if (lastSaveCopyDirectory.isEmpty())
          lastSaveCopyDirectory = settings.value("lastSaveCopyDirectory", preferences.myScoresPath).toString();
      if (lastSaveDirectory.isEmpty())
          lastSaveDirectory = settings.value("lastSaveDirectory", preferences.myScoresPath).toString();
      QString saveDirectory = lastSaveCopyDirectory;

      if (saveDirectory.isEmpty()) {
          saveDirectory = preferences.myScoresPath;
          }

      if (saveDirectory.isEmpty())
            saveDirectory = preferences.myScoresPath;

      if (lastSaveCopyFormat.isEmpty())
            lastSaveCopyFormat = settings.value("lastSaveCopyFormat", "pdf").toString();
      QString saveFormat = lastSaveCopyFormat;

      if (saveFormat.isEmpty())
            saveFormat = "pdf";

      QString scoreName = (cs->isMaster() ? cs : cs->masterScore())->fileInfo()->completeBaseName();
      QString name;
#ifdef Q_OS_WIN
      if (QSysInfo::WindowsVersion == QSysInfo::WV_XP)
            name = QString("%1/%2").arg(saveDirectory).arg(scoreName);
      else
#endif
      name = QString("%1/%2.%3").arg(saveDirectory).arg(scoreName).arg(saveFormat);

      int idx = fl.indexOf(QRegExp(".+\\(\\*\\." + saveFormat + "\\)"), Qt::CaseInsensitive);
      if (idx != -1)
            fl.move(idx, 0);
      QString filter = fl.join(";;");
      QString fn = getSaveScoreName(saveDialogTitle, name, filter);
      if (fn.isEmpty())
          return false;

      QFileInfo fi(fn);
      lastSaveCopyDirectory = fi.absolutePath();
      lastSaveCopyFormat = fi.suffix();

      QString ext = fi.suffix();
      if (ext.isEmpty()) {
            QMessageBox::critical(this, tr("MuseScore: Export Parts"), tr("Cannot determine file type"));
            return false;
            }

      Score* thisScore = cs->masterScore();
      bool overwrite = false;
      bool noToAll = false;
      QString confirmReplaceTitle = tr("Confirm Replace");
      QString confirmReplaceMessage = tr("\"%1\" already exists.\nDo you want to replace it?\n");
      QString replaceMessage = tr("Replace");
      QString skipMessage = tr("Skip");
      foreach (Excerpt* e, thisScore->excerpts())  {
            Score* pScore = e->partScore();
            QString partfn = fi.absolutePath() + QDir::separator() + fi.completeBaseName() + "-" + createDefaultFileName(pScore->fileInfo()->completeBaseName()) + "." + ext;
            QFileInfo fip(partfn);
            if(fip.exists() && !overwrite) {
                  if(noToAll)
                        continue;
                  QMessageBox msgBox( QMessageBox::Question, confirmReplaceTitle,
                        confirmReplaceMessage.arg(QDir::toNativeSeparators(partfn)),
                        QMessageBox::Yes |  QMessageBox::YesToAll | QMessageBox::No |  QMessageBox::NoToAll);
                  msgBox.setButtonText(QMessageBox::Yes, replaceMessage);
                  msgBox.setButtonText(QMessageBox::No, skipMessage);
                  msgBox.setButtonText(QMessageBox::YesToAll, tr("Replace All"));
                  msgBox.setButtonText(QMessageBox::NoToAll, tr("Skip All"));
                  int sb = msgBox.exec();
                  if(sb == QMessageBox::YesToAll) {
                        overwrite = true;
                        }
                  else if (sb == QMessageBox::NoToAll) {
                        noToAll = true;
                        continue;
                        }
                  else if (sb == QMessageBox::No)
                        continue;
                  }

            if (!saveAs(pScore, true, partfn, ext))
                  return false;
            }
      // For PDF, also export score and parts together
      if (ext.toLower() == "pdf") {
            QList<Score*> scores;
            scores.append(thisScore);
            foreach(Excerpt* e, thisScore->excerpts())  {
                  scores.append(e->partScore());
                  }
            QString partfn(fi.absolutePath() + QDir::separator() + fi.completeBaseName() + "-" + createDefaultFileName(tr("Score_and_Parts")) + ".pdf");
            QFileInfo fip(partfn);
            if(fip.exists() && !overwrite) {
                  if (!noToAll) {
                        QMessageBox msgBox( QMessageBox::Question, confirmReplaceTitle,
                              confirmReplaceMessage.arg(QDir::toNativeSeparators(partfn)),
                              QMessageBox::Yes | QMessageBox::No);
                        msgBox.setButtonText(QMessageBox::Yes, replaceMessage);
                        msgBox.setButtonText(QMessageBox::No, skipMessage);
                        int sb = msgBox.exec();
                        if(sb == QMessageBox::Yes) {
                              if (!savePdf(scores, partfn))
                                    return false;
                              }
                        }
                  }
            else if (!savePdf(scores, partfn))
                  return false;
      }
      if(!noToAll)
            QMessageBox::information(this, tr("MuseScore: Export Parts"), tr("Parts were successfully exported"));
      return true;
      }

//---------------------------------------------------------
//   saveAs
//---------------------------------------------------------

bool MuseScore::saveAs(Score* cs, bool saveCopy, const QString& path, const QString& ext)
      {
      bool rv = false;
      QString suffix = "." + ext;
      QString fn(path);
      if (!fn.endsWith(suffix))
            fn += suffix;

      LayoutMode layoutMode = cs->layoutMode();
      if (ext == "mscx" || ext == "mscz") {
            // save as mscore *.msc[xz] file
            QFileInfo fi(fn);
            rv = true;
            // store new file and path into score fileInfo
            // to have it accessible to resources
            QString originalScoreFName(cs->masterScore()->fileInfo()->canonicalFilePath());
            cs->masterScore()->fileInfo()->setFile(fn);
            try {
                  if (ext == "mscz")
                        cs->saveCompressedFile(fi, false);
                  else
                        cs->saveFile(fi);
                  }
            catch (QString s) {
                  rv = false;
                  QMessageBox::critical(this, tr("MuseScore: Save As"), s);
                  }
            cs->masterScore()->fileInfo()->setFile(originalScoreFName);          // restore original file name

            if (rv && !saveCopy) {
                  cs->masterScore()->fileInfo()->setFile(fn);
                  setWindowTitle("MuseScore: " + cs->fileInfo()->completeBaseName());
                  cs->undoStack()->setClean();
                  dirtyChanged(cs);
                  cs->setCreated(false);
                  addRecentScore(cs);
                  writeSessionFile(false);
                  }
            }
      else if (ext == "xml") {
            // save as MusicXML *.xml file
            rv = saveXml(cs, fn);
            }
      else if (ext == "mxl") {
            // save as compressed MusicXML *.mxl file
            rv = saveMxl(cs, fn);
            }
      else if (ext == "mid") {
            // save as midi file *.mid
            rv = saveMidi(cs, fn);
            }
      else if (ext == "pdf") {
            // save as pdf file *.pdf
            cs->switchToPageMode();
            rv = savePdf(cs, fn);
            }
      else if (ext == "png") {
            // save as png file *.png
            cs->switchToPageMode();
            rv = savePng(cs, fn);
            }
      else if (ext == "svg") {
            // save as svg file *.svg
            cs->switchToPageMode();
            rv = saveSvg(cs, fn);
            }
#ifdef HAS_AUDIOFILE
      else if (ext == "wav" || ext == "flac" || ext == "ogg")
            rv = saveAudio(cs, fn);
#endif
#ifdef USE_LAME
      else if (ext == "mp3")
            rv = saveMp3(cs, fn);
#endif
      else if (ext == "spos") {
            cs->switchToPageMode();
            // save positions of segments
            rv = savePositions(cs, fn, true);
            }
      else if (ext == "mpos") {
            cs->switchToPageMode();
            // save positions of measures
            rv = savePositions(cs, fn, false);
            }
      else if (ext == "mlog") {
            rv = cs->sanityCheck(fn);
            }
      else {
            qDebug("Internal error: unsupported extension <%s>",
               qPrintable(ext));
            return false;
            }
      if (!rv && !MScore::noGui)
            QMessageBox::critical(this, tr("MuseScore:"), tr("Cannot write into %1").arg(fn));
      if (layoutMode != cs->layoutMode())
            cs->endCmd(true);       // rollback
      return rv;
      }

//---------------------------------------------------------
//   saveMidi
//---------------------------------------------------------

bool MuseScore::saveMidi(Score* score, const QString& name)
      {
      ExportMidi em(score);
      return em.write(name, preferences.midiExpandRepeats);
      }

//---------------------------------------------------------
//   savePdf
//---------------------------------------------------------

bool MuseScore::savePdf(const QString& saveName)
      {
      return savePdf(cs, saveName);
      }

bool MuseScore::savePdf(Score* cs, const QString& saveName)
      {
      cs->setPrinting(true);
      MScore::pdfPrinting = true;
      QPdfWriter printerDev(saveName);
      printerDev.setResolution(preferences.exportPdfDpi);
      const PageFormat* pf = cs->pageFormat();
      printerDev.setPageSize(QPageSize(pf->size(), QPageSize::Inch));

      printerDev.setCreator("MuseScore Version: " VERSION);
      if (!printerDev.setPageMargins(QMarginsF()))
            qDebug("unable to clear printer margins");
      printerDev.setTitle(cs->fileInfo()->completeBaseName());

      QPainter p;
      if (!p.begin(&printerDev))
            return false;
      p.setRenderHint(QPainter::Antialiasing, true);
      p.setRenderHint(QPainter::TextAntialiasing, true);
      double mag = printerDev.logicalDpiX() / DPI;
      p.scale(mag, mag);

      const QList<Page*> pl = cs->pages();
      int pages    = pl.size();
      bool firstPage = true;
      for (int n = 0; n < pages; ++n) {
            if (!firstPage)
                  printerDev.newPage();
            firstPage = false;
            cs->print(&p, n);
            }
      p.end();
      cs->setPrinting(false);
      MScore::pdfPrinting = false;
      return true;
      }

bool MuseScore::savePdf(QList<Score*> cs, const QString& saveName)
      {
      if (cs.empty())
            return false;
      Score* firstScore = cs[0];

      QPrinter printerDev(QPrinter::HighResolution);
      const PageFormat* pf = firstScore->pageFormat();
      printerDev.setPaperSize(pf->size(), QPrinter::Inch);

      printerDev.setCreator("MuseScore Version: " VERSION);
      printerDev.setFullPage(true);
      if (!printerDev.setPageMargins(QMarginsF()))
            qDebug("unable to clear printer margins");
      printerDev.setColorMode(QPrinter::Color);
      printerDev.setDocName(firstScore->fileInfo()->completeBaseName());
      printerDev.setOutputFormat(QPrinter::PdfFormat);

      printerDev.setOutputFileName(saveName);

      QPainter p;
      if (!p.begin(&printerDev))
            return false;

      p.setRenderHint(QPainter::Antialiasing, true);
      p.setRenderHint(QPainter::TextAntialiasing, true);
      double mag = printerDev.logicalDpiX() / DPI;
      p.scale(mag, mag);

      bool firstPage = true;
      for (Score* s : cs) {
            LayoutMode layoutMode = s->layoutMode();
            s->switchToPageMode();
            s->setPrinting(true);
            MScore::pdfPrinting = true;

            const PageFormat* pf = s->pageFormat();
            printerDev.setPaperSize(pf->size(), QPrinter::Inch);

            const QList<Page*> pl = s->pages();
            int pages    = pl.size();
            for (int n = 0; n < pages; ++n) {
                  if (!firstPage)
                        printerDev.newPage();
                  firstPage = false;
                  s->print(&p, n);
                  }
            //reset score
            s->setPrinting(false);
            MScore::pdfPrinting = false;

            if (layoutMode != s->layoutMode())
                  s->endCmd(true);       // rollback
            }
      p.end();
      return true;
      }

//---------------------------------------------------------
//   importSoundfont
//---------------------------------------------------------

void importSoundfont(QString name)
      {
      QFileInfo info(name);
      int ret = QMessageBox::question(0, QWidget::tr("Install SoundFont"),
            QWidget::tr("Do you want to install the SoundFont %1?").arg(info.fileName()),
             QMessageBox::Yes|QMessageBox::No, QMessageBox::NoButton);
      if (ret == QMessageBox::Yes) {
            QStringList pl = preferences.mySoundfontsPath.split(";");
            QString destPath;
            for (QString s : pl) {
                  QFileInfo dest(s);
                  if (dest.isWritable())
                        destPath = s;
                  }
            if (!destPath.isEmpty()) {
                  QString destFilePath = destPath+ "/" +info.fileName();
                  QFileInfo destFileInfo(destFilePath);
                  QFile destFile(destFilePath);
                  if (destFileInfo.exists()) {
                        int ret1 = QMessageBox::question(0, QWidget::tr("Overwrite?"),
                          QWidget::tr("%1 already exists.\nDo you want to overwrite it?").arg(destFileInfo.absoluteFilePath()),
                          QMessageBox::Yes|QMessageBox::No, QMessageBox::No);
                        if (ret1 == QMessageBox::No)
                              return;
                        destFile.remove();
                        }
                  QFile orig(name);
                  if (orig.copy(destFilePath)) {
                        QMessageBox::information(0, QWidget::tr("SoundFont installed"), QWidget::tr("SoundFont installed. Please go to View > Synthesizer to add it and View > Mixer to choose an instrument sound."));
                        }
                  }
            }
      }

//---------------------------------------------------------
//   readScore
///   Import file \a name
//---------------------------------------------------------

Score::FileError readScore(MasterScore* score, QString name, bool ignoreVersionError)
      {
      QFileInfo info(name);
      QString suffix  = info.suffix().toLower();
      score->setName(info.completeBaseName());
      score->setImportedFilePath(name);

      if (suffix == "mscz" || suffix == "mscx") {
            Score::FileError rv = score->loadMsc(name, ignoreVersionError);
            if (score && score->masterScore()->fileInfo()->path().startsWith(":/"))
                  score->setCreated(true);
            if (rv != Score::FileError::FILE_NO_ERROR)
                  return rv;
            }
      else if (suffix == "sf2" || suffix == "sf3") {
            importSoundfont(name);
            return Score::FileError::FILE_IGNORE_ERROR;
            }
      else {
            // typedef Score::FileError (*ImportFunction)(MasterScore*, const QString&);
            struct ImportDef {
                  const char* extension;
                  // ImportFunction importF;
                  Score::FileError (*importF)(MasterScore*, const QString&);
                  };
            static const ImportDef imports[] = {
                  { "xml",  &importMusicXml           },
                  { "mxl",  &importCompressedMusicXml },
                  { "mid",  &importMidi               },
                  { "midi", &importMidi               },
                  { "kar",  &importMidi               },
                  { "md",   &importMuseData           },
                  { "mgu",  &importBB                 },
                  { "sgu",  &importBB                 },
                  { "cap",  &importCapella            },
                  { "capx", &importCapXml             },
                  { "ove",  &importOve                },
                  { "scw",  &importOve                },
#ifdef OMR
                  { "pdf",  &importPdf                },
#endif
                  { "bww",  &importBww                },
                  { "gtp",  &importGTP                },
                  { "gp3",  &importGTP                },
                  { "gp4",  &importGTP                },
                  { "gp5",  &importGTP                },
                  { "gpx",  &importGTP                },
                  };

            // import
            if (!preferences.importStyleFile.isEmpty()) {
                  QFile f(preferences.importStyleFile);
                  // silently ignore style file on error
                  if (f.open(QIODevice::ReadOnly))
                        score->style()->load(&f);
                  }
            else {
                  if (score->style()->value(StyleIdx::chordsXmlFile).toBool())
                        score->style()->chordList()->read("chords.xml");
                  score->style()->chordList()->read(score->styleSt(StyleIdx::chordDescriptionFile));
                  }
            bool found = false;
            for (auto i : imports) {
                  if (i.extension == suffix) {
                        Score::FileError rv = (*i.importF)(score, name);
                        if (rv != Score::FileError::FILE_NO_ERROR)
                              return rv;
                        found = true;
                        break;
                        }
                  }
            if (!found) {
                  qDebug("unknown file suffix <%s>, name <%s>", qPrintable(suffix), qPrintable(name));
                  return Score::FileError::FILE_UNKNOWN_TYPE;
                  }
            score->setMetaTag("originalFormat", suffix);
            score->connectTies();
            score->setCreated(true); // force save as for imported files
            }

      score->rebuildMidiMapping();
      score->setSoloMute();
      for (Score* s : score->scoreList()) {
            s->setPlaylistDirty();
            s->addLayoutFlags(LayoutFlag::FIX_PITCH_VELO);
            s->setLayoutAll();
            }
      score->updateChannel();
      score->setSaved(false);
      score->update();

      if (!ignoreVersionError && !MScore::noGui)
            if (!score->sanityCheck(QString()))
                  return Score::FileError::FILE_CORRUPTED;
      return Score::FileError::FILE_NO_ERROR;
      }

//---------------------------------------------------------
//   saveAs
//    return true on success
//---------------------------------------------------------

/**
 Save the current score using a different name or type.
 Handles the GUI's file-save-as and file-save-a-copy actions.
 The saveCopy flag, if true, does not change the name of the active score nor marks it clean.
 Return true if OK and false on error.
 */

bool MuseScore::saveAs(Score* cs, bool saveCopy)
      {
      QStringList fl;
      fl.append(tr("MuseScore File (*.mscz)"));
      fl.append(tr("Uncompressed MuseScore File (*.mscx)"));     // for debugging purposes
      QString saveDialogTitle = saveCopy ? tr("MuseScore: Save a Copy") :
                                           tr("MuseScore: Save As");

      QSettings settings;
      if (mscore->lastSaveCopyDirectory.isEmpty())
            mscore->lastSaveCopyDirectory = settings.value("lastSaveCopyDirectory", preferences.myScoresPath).toString();
      if (mscore->lastSaveDirectory.isEmpty())
            mscore->lastSaveDirectory = settings.value("lastSaveDirectory", preferences.myScoresPath).toString();
      QString saveDirectory = saveCopy ? mscore->lastSaveCopyDirectory : mscore->lastSaveDirectory;

      if (saveDirectory.isEmpty())
            saveDirectory = preferences.myScoresPath;

      QString name;
#ifdef Q_OS_WIN
      if (QSysInfo::WindowsVersion == QSysInfo::WV_XP) {
            if (!cs->isMaster())
                  name = QString("%1/%2-%3").arg(saveDirectory).arg(cs->masterScore()->fileInfo()->completeBaseName()).arg(createDefaultFileName(cs->fileInfo()->completeBaseName()));
            else
                  name = QString("%1/%2").arg(saveDirectory).arg(cs->fileInfo()->completeBaseName());
            }
      else
#endif
      if (!cs->isMaster())
            name = QString("%1/%2-%3.mscz").arg(saveDirectory).arg(cs->masterScore()->fileInfo()->completeBaseName()).arg(createDefaultFileName(cs->fileInfo()->completeBaseName()));
      else
            name = QString("%1/%2.mscz").arg(saveDirectory).arg(cs->fileInfo()->completeBaseName());

      QString filter = fl.join(";;");
      QString fn     = mscore->getSaveScoreName(saveDialogTitle, name, filter);
      if (fn.isEmpty())
            return false;

      QFileInfo fi(fn);
      if (saveCopy)
            mscore->lastSaveCopyDirectory = fi.absolutePath();
      else
            mscore->lastSaveDirectory = fi.absolutePath();

      if (fi.suffix().isEmpty()) {
            if (!MScore::noGui)
                  QMessageBox::critical(mscore, tr("MuseScore: Save As"), tr("Cannot determine file type"));
            return false;
            }
      return saveAs(cs, saveCopy, fn, fi.suffix());
      }

//---------------------------------------------------------
//   saveSelection
//    return true on success
//---------------------------------------------------------

bool MuseScore::saveSelection(Score* cs)
      {
      if (!cs->selection().isRange()) {
            if(!MScore::noGui) QMessageBox::warning(mscore, tr("MuseScore: Save Selection"), tr("Please select one or more measures"));
            return false;
            }
      QStringList fl;
      fl.append(tr("MuseScore File (*.mscz)"));
      QString saveDialogTitle = tr("MuseScore: Save Selection");

      QSettings settings;
      if (mscore->lastSaveDirectory.isEmpty())
            mscore->lastSaveDirectory = settings.value("lastSaveDirectory", preferences.myScoresPath).toString();
      QString saveDirectory = mscore->lastSaveDirectory;

      if (saveDirectory.isEmpty())
            saveDirectory = preferences.myScoresPath;

      QString name   = QString("%1/%2.mscz").arg(saveDirectory).arg(cs->fileInfo()->completeBaseName());
      QString filter = fl.join(";;");
      QString fn     = mscore->getSaveScoreName(saveDialogTitle, name, filter);
      if (fn.isEmpty())
            return false;

      QFileInfo fi(fn);
      mscore->lastSaveDirectory = fi.absolutePath();

      QString ext = fi.suffix();
      if (ext.isEmpty()) {
            QMessageBox::critical(mscore, tr("MuseScore: Save Selection"), tr("Cannot determine file type"));
            return false;
            }
      bool rv = true;
      try {
            cs->saveCompressedFile(fi, true);
            }
      catch (QString s) {
            rv = false;
            QMessageBox::critical(this, tr("MuseScore: Save Selected"), s);
            }
      return rv;
      }

//---------------------------------------------------------
//   addImage
//---------------------------------------------------------

void MuseScore::addImage(Score* score, Element* e)
      {
      QString fn = QFileDialog::getOpenFileName(
         0,
         tr("MuseScore: Insert Image"),
         "",            // lastOpenPath,
         tr("All Supported Files (*.svg *.jpg *.jpeg *.png);;"
            "Scalable Vector Graphics (*.svg);;"
            "JPEG (*.jpg *.jpeg);;"
            "PNG (*.png)"
            )
         );
      if (fn.isEmpty())
            return;

      QFileInfo fi(fn);
      Image* s = new Image(score);
      QString suffix(fi.suffix().toLower());

      if (suffix == "svg")
            s->setImageType(ImageType::SVG);
      else if (suffix == "jpg" || suffix == "jpeg" || suffix == "png")
            s->setImageType(ImageType::RASTER);
      else
            return;
      s->load(fn);
      s->setParent(e);
      score->undoAddElement(s);
      }

#if 0
//---------------------------------------------------------
//   trim
//    returns copy of source with whitespace trimmed and margin added
//---------------------------------------------------------

static QRect trim(QImage source, int margin)
      {
      int w = source.width();
      int h = source.height();
      int x1 = w;
      int x2 = 0;
      int y1 = h;
      int y2 = 0;
      for (int x = 0; x < w; ++x) {
            for (int y = 0; y < h; ++y) {
                  QRgb c = source.pixel(x, y);
                  if (c != 0 && c != 0xffffffff) {
                        if (x < x1)
                              x1 = x;
                        if (x > x2)
                              x2 = x;
                        if (y < y1)
                              y1 = y;
                        if (y > y2)
                              y2 = y;
                        }
                  }
            }
      int x = qMax(x1 - margin, 0);
      int y = qMax(y1 - margin, 0);
      w = qMin(w, x2 + 1 + margin) - x;
      h = qMin(h, y2 + 1 + margin) - y;
      return QRect(x, y, w, h);
      }
#endif

//---------------------------------------------------------
//   savePng
//    return true on success
//---------------------------------------------------------

bool MuseScore::savePng(Score* score, const QString& name)
      {
      return savePng(score, name, false, preferences.pngTransparent, converterDpi, trimMargin, QImage::Format_ARGB32_Premultiplied);
      }

//---------------------------------------------------------
//   savePng with options
//    return true on success
//---------------------------------------------------------

bool MuseScore::savePng(Score* score, const QString& name, bool screenshot, bool transparent, double convDpi, int trimMargin, QImage::Format format)
      {
      bool rv = true;
      score->setPrinting(!screenshot);    // dont print page break symbols etc.

      QImage::Format f;
      if (format != QImage::Format_Indexed8)
          f = format;
      else
          f = QImage::Format_ARGB32_Premultiplied;

      const QList<Page*>& pl = score->pages();
      int pages = pl.size();

      int padding = QString("%1").arg(pages).size();
      bool overwrite = false;
      bool noToAll = false;
      for (int pageNumber = 0; pageNumber < pages; ++pageNumber) {
            Page* page = pl.at(pageNumber);

            QRectF r;
            if (trimMargin >= 0) {
                  QMarginsF margins(trimMargin, trimMargin, trimMargin, trimMargin);
                  r = page->tbbox() + margins;
                  }
            else
                  r = page->abbox();
            int w = lrint(r.width()  * convDpi / DPI);
            int h = lrint(r.height() * convDpi / DPI);

            QImage printer(w, h, f);
            printer.setDotsPerMeterX(lrint((convDpi * 1000) / INCH));
            printer.setDotsPerMeterY(lrint((convDpi * 1000) / INCH));

            printer.fill(transparent ? 0 : 0xffffffff);

            double mag = convDpi / DPI;
            QPainter p(&printer);
            p.setRenderHint(QPainter::Antialiasing, true);
            p.setRenderHint(QPainter::TextAntialiasing, true);
            p.scale(mag, mag);
            if (trimMargin >= 0)
                  p.translate(-r.topLeft());

            QList<Element*> pel = page->elements();
            qStableSort(pel.begin(), pel.end(), elementLessThan);
            paintElements(p, pel);

            if (format == QImage::Format_Indexed8) {
                  //convert to grayscale & respect alpha
                  QVector<QRgb> colorTable;
                  colorTable.push_back(QColor(0, 0, 0, 0).rgba());
                  if (!transparent) {
                        for (int i = 1; i < 256; i++)
                              colorTable.push_back(QColor(i, i, i).rgb());
                        }
                  else {
                        for (int i = 1; i < 256; i++)
                              colorTable.push_back(QColor(0, 0, 0, i).rgba());
                        }
                  printer = printer.convertToFormat(QImage::Format_Indexed8, colorTable);
                  }

            QString fileName(name);
            if (fileName.endsWith(".png"))
                  fileName = fileName.left(fileName.size() - 4);
            fileName += QString("-%1.png").arg(pageNumber+1, padding, 10, QLatin1Char('0'));
            if (!converterMode) {
                  QFileInfo fip(fileName);
                  if(fip.exists() && !overwrite) {
                        if(noToAll)
                              continue;
                        QMessageBox msgBox( QMessageBox::Question, tr("Confirm Replace"),
                              tr("\"%1\" already exists.\nDo you want to replace it?\n").arg(QDir::toNativeSeparators(fileName)),
                              QMessageBox::Yes |  QMessageBox::YesToAll | QMessageBox::No |  QMessageBox::NoToAll);
                        msgBox.setButtonText(QMessageBox::Yes, tr("Replace"));
                        msgBox.setButtonText(QMessageBox::No, tr("Skip"));
                        msgBox.setButtonText(QMessageBox::YesToAll, tr("Replace All"));
                        msgBox.setButtonText(QMessageBox::NoToAll, tr("Skip All"));
                        int sb = msgBox.exec();
                        if(sb == QMessageBox::YesToAll) {
                              overwrite = true;
                              }
                        else if (sb == QMessageBox::NoToAll) {
                              noToAll = true;
                              continue;
                              }
                        else if (sb == QMessageBox::No)
                              continue;
                        }
                  }
            rv = printer.save(fileName, "png");
            if (!rv)
                  break;
            }
      cs->setPrinting(false);
      return rv;
      }

//---------------------------------------------------------
//   WallpaperPreview
//---------------------------------------------------------

WallpaperPreview::WallpaperPreview(QWidget* parent)
   : QFrame(parent)
      {
      _pixmap = 0;
      }

//---------------------------------------------------------
//   paintEvent
//---------------------------------------------------------

void WallpaperPreview::paintEvent(QPaintEvent* ev)
      {
      QPainter p(this);
      int fw = frameWidth();
      QRect r(frameRect().adjusted(fw, fw, -2*fw, -2*fw));
      if (_pixmap)
            p.drawTiledPixmap(r, *_pixmap);
      QFrame::paintEvent(ev);
      }

//---------------------------------------------------------
//   setImage
//---------------------------------------------------------

void WallpaperPreview::setImage(const QString& path)
      {
      qDebug("setImage <%s>", qPrintable(path));
      delete _pixmap;
      _pixmap = new QPixmap(path);
      update();
      }

//---------------------------------------------------------
//   getWallpaper
//---------------------------------------------------------

QString MuseScore::getWallpaper(const QString& caption)
      {
      QString filter = tr("Images (*.jpg *.jpeg *.png);;All (*)");
      QString d = mscoreGlobalShare + "/wallpaper";

      if (preferences.nativeDialogs) {
            QString s = QFileDialog::getOpenFileName(
               this,                            // parent
               caption,
               d,
               filter
               );
            return s;
            }

      if (loadBackgroundDialog == 0) {
            loadBackgroundDialog = new QFileDialog(this);
            loadBackgroundDialog->setFileMode(QFileDialog::ExistingFile);
            loadBackgroundDialog->setOption(QFileDialog::DontUseNativeDialog, true);
            loadBackgroundDialog->setWindowTitle(caption);
            loadBackgroundDialog->setNameFilter(filter);
            loadBackgroundDialog->setDirectory(d);

            QSettings settings;
            loadBackgroundDialog->restoreState(settings.value("loadBackgroundDialog").toByteArray());
            loadBackgroundDialog->setAcceptMode(QFileDialog::AcceptOpen);

            QSplitter* splitter = loadBackgroundDialog->findChild<QSplitter*>("splitter");
            if (splitter) {
                  WallpaperPreview* preview = new WallpaperPreview;
                  splitter->addWidget(preview);
                  connect(loadBackgroundDialog, SIGNAL(currentChanged(const QString&)),
                     preview, SLOT(setImage(const QString&)));
                  }
            }

      //
      // setup side bar urls
      //
      QList<QUrl> urls;
      QString home = QDir::homePath();
      urls.append(QUrl::fromLocalFile(d));
      urls.append(QUrl::fromLocalFile(home));
      urls.append(QUrl::fromLocalFile(QDir::currentPath()));
      loadBackgroundDialog->setSidebarUrls(urls);

      if (loadBackgroundDialog->exec()) {
            QStringList result = loadBackgroundDialog->selectedFiles();
            return result.front();
            }
      return QString();
      }

///////////////////////////////////////////////////////////////////////////////
// SVG function:
//   saveSvg()         the one, the original, fully integrated into MuseScore (not quite fully yet...)
// Shared SVG and SMAWS functions:
//   svgInit()         initializes variables prior exporting a score
//   paintStaffLines() paints SVG staff lines more efficiently
// Pure SMAWS:
//   saveSMAWS()       writes linked SVG and VTT files for animation
//   saveVTT()         a helper function exclusively for saveSMAWS()
//   getCueID()        another little helper (Cue IDs link SVG to VTT)
//   getAnnCueID()     gets Annotation Cue ID (Harmony and RehearsalMark)
//   getScrollCueID()  gets Cue ID for scrolling cues and RehearsalMarks
///////////////////////////////////////////////////////////////////////////////
// paintStaffLines() - consolidates shared code in saveSVG() and saveSMAWS()
//                     for MuseScore master, no harm, no gain, 100% neutral
static void paintStaffLines(Score*        score,
                            QPainter*     p,
                            SvgGenerator* printer,
                            Page*         page,
                            QVector<int>* pVisibleStaves =  0,
                            int           idxStaff       = -1, // element.staffIdx()
                            bool          isMulti        = false,
                            QStringList*  pINames        =  0,
                            QList<qreal>* pStaffTops     =  0)
{
    const qreal cursorOverlap = Ms::SPATIUM20 / 2; // 1/2 spatium top + bottom

    bool  isFirst = true;
    qreal cursorTop;
    qreal cursorBot;

    if (isMulti && idxStaff > -1 && pINames != 0) {
        // isMulti requires a <g></g> wrapper around each staff's elements
        QString qs = score->systems().first()->staff(idxStaff)->instrumentNames.first()->xmlText(); ///!!!this line of code crashes for piano-style dual-staff (linked staves?)!!!
        pINames->append(qs.replace(SVG_SPACE, SVG_DASH));
        SysStaff* ss = page->systems().value(0)->staff(idxStaff);
//TODO: distanceDown() distanceUp()        printer->beginMultiGroup(pINames,
//TODO: distanceDown() distanceUp()                                 score->staff(idxStaff)->part()->shortName(0),
//TODO: distanceDown() distanceUp()                                 ss->bbox().height() + ss->distanceDown(),
//TODO: distanceDown() distanceUp()                                 ss->distanceUp());
        printer->setCueID("");
    }

    for (System* s : page->systems()) {
        for (int i = 0, n = s->staves()->size(); i < n; i++) {
            qreal staffTop;
            StaffLines* sl;

            // Ignore invisible staves
            if (score->staff(i)->invisible())
                continue;

            if (idxStaff > -1)
                i = idxStaff; // Only one staff's lines being drawn

            // SMAWS scores need the top y-coord and height of the first system
            // for the highlight cursor. This is the best place to calculate it,
            // especially for vertical scores. It assumes all systems are the
            // same height. Systems and staves are in top-to-bottom order here.
            if (pVisibleStaves != 0) {
                printer->setStaffIndex(pVisibleStaves->value(i));
                if (isFirst) {
                    sl        = s->firstMeasure()->staffLines(i);
                    staffTop  = sl->bbox().top()+ sl->pagePos().y();
                    int j;
                    // Get the first visible staff index (in the first system)
                    for (j = 0; j < pVisibleStaves->size(); j++) {
                        if (pVisibleStaves->value(j) >= 0)
                            break;
                    }
                    if (i == j) { // First visible staff in the first system
                        // Set the cursor's y-coord
                        cursorTop = staffTop - cursorOverlap;
                        printer->setCursorTop(cursorTop);

                        // Get the last visible staff index in the first system
                        for (j = pVisibleStaves->size() - 1; j >= 0; j--) {
                            if (pVisibleStaves->value(j) >= 0)
                                break;
                        }
                        // Set the cursor's height
                        sl        = s->firstMeasure()->staffLines(j);
                        cursorBot = sl->bbox().top()
                                  + sl->pagePos().y()
                                  + score->staff(i)->height() // bbox().bottom() includes margins
                                  + cursorOverlap;
                        printer->setCursorHeight(cursorBot - cursorTop);
                    }
                    if (isMulti && pStaffTops != 0) {
                        // Offset between this staff and the first visible staff
                        pStaffTops->append(staffTop);
                        printer->setYOffset(pStaffTops->value(0) - staffTop);
                    }
                }
            }

            // The goal here is to draw SVG staff lines more efficiently.
            // MuseScore draws staff lines by measure, but for SVG they can
            // generally be drawn once for each system. This makes a big
            // difference for scores that scroll horizontally on a single
            // page. But there is an exception to this rule:
            //
            //   ~ One (or more) invisible measure(s) in a system/staff ~
            //     In this case the SVG staff lines for the system/staff
            //     are drawn by measure.
            //
            bool byMeasure = false;
            for (MeasureBase* mb = s->firstMeasure(); mb != 0; mb = s->nextMeasure(mb)) {
                if (!static_cast<Measure*>(mb)->visible(i)) {
                    byMeasure = true;
                    break;
                }
            }
            if (byMeasure) { // Draw visible staff lines by measure
                for (MeasureBase* mb = s->firstMeasure(); mb != 0; mb = s->nextMeasure(mb)) {
                    Measure* m = static_cast<Measure*>(mb);
                    if (m->visible(i)) {
                        sl = m->staffLines(i);
                        printer->setElement(sl);
                        paintElement(*p, sl);
                    }
                }
            }
            else { // Draw staff lines once per system
                StaffLines* firstSL = s->firstMeasure()->staffLines(i)->clone();
                StaffLines*  lastSL =  s->lastMeasure()->staffLines(i);
                firstSL->bbox().setRight(lastSL->bbox().right()
                                      +  lastSL->pagePos().x()
                                      - firstSL->pagePos().x());
                printer->setElement(firstSL);
                paintElement(*p, firstSL);
            }

            if (idxStaff != -1) // No need to break from outer loop,
                break;          // because score has only one system.

        } // for each Staff
        isFirst = false;

    } //for each System

}

// svgInit() - consolidates shared code in saveSVG and saveSMAWS.
//             for MuseScore master, no harm, no gain, 100% neutral
static bool svgInit(Score*        score,
              const QString&      saveName,
                    SvgGenerator* printer,
                    QPainter*     p,
                    bool          bSMAWS = false)
{
    printer->setFileName(saveName);
    if (!p->begin(printer))
        return false;

    printer->setTitle(score->title());
    score->setPrinting(true);
    MScore::pdfPrinting = true;
    p->setRenderHint(QPainter::Antialiasing, true);
    p->setRenderHint(QPainter::TextAntialiasing, true);

    QRectF r;
    if (trimMargin >= 0 && score->npages() == 1) {
        QMarginsF margins(trimMargin, trimMargin, trimMargin, trimMargin);
        r = score->pages().first()->tbbox() + margins;
    }
    else {
        const PageFormat* pf = score->pageFormat();
        r = QRectF(0, 0, pf->width() * score->pages().size(), pf->height());
    }
    qreal w = r.width();
    qreal h = r.height();
    if (trimMargin >= 0 && score->npages() == 1)
          p->translate(-r.topLeft());

    // The relationship between the viewBox dimensions and the width/height
    // values, combined with the preserveAspectRatio value, determine default
    // scaling inside the SVG file. (preserveAspectRatio="xMinYMin slice")
    printer->setViewBox(QRectF(0, 0, w, h));
    if (bSMAWS)
        // SMAWS: No scaling inside the SVG (scale factor = 1)
        printer->setSize(QSize(w, h));
    else {
        // MuseScore: SVG scale factor = screen scale factor
        qreal scaleFactor;
        scaleFactor = 1; //!!!TODO: get scale factor
        printer->setSize(QSize(w * scaleFactor, h * scaleFactor));
    }

    return true;
}

// MuseScore::saveSvg() - This version is compatible with MuseScore master if
//                        svgInit() + paintStaffLines() are integrated as well.
bool MuseScore::saveSvg(Score* score, const QString& saveName)
{
    // Initialize
    SvgGenerator printer;
    QPainter p;
    if (!svgInit(score, saveName, &printer, &p))
        return false;

    // Print/paint/draw/whatever-you-want-to-call-it
    foreach (Page* page, score->pages()) {
        // 1st pass: StaffLines
        paintStaffLines(score, &p, &printer, page);

        // 2nd pass: the rest of the elements
        QList<Element*> pel = page->elements();
        qStableSort(pel.begin(), pel.end(), elementLessThan);

        Element::Type eType;
        foreach (const Element* e, pel) {
            // Always exclude invisible elements
            if (!e->visible())
                    continue;

            eType = e->type();
            switch (eType) { // In future sub-type code, this switch() grows, and eType gets used
            case EType::STAFF_LINES : // Handled in the 1st pass above
                continue; // Exclude from 2nd pass
                break;
            default:
                break;
            } // switch(eType)

            // Set the Element pointer inside SvgGenerator/SvgPaintEngine
            printer.setElement(e);

            // Paint it
            paintElement(p, e);
        }
        // Future code will create separate files for each page,
        // so this horizontal offset page-simulation will disappear.
        p.translate(QPointF(score->pageFormat()->width(), 0.0));
    }

      // Clean up and return
      score->setPrinting(false);
      MScore::pdfPrinting = false;
      p.end(); // Writes MuseScore SVG file to disk, finally
      return true;
}
///////////////////////////////////////////////////////////////////////////////
// SMAWS functions - 100% outside of MuseScore master (at least for now...)
///////////////////////////////////////////////////////////////////////////////

// Static helper functions. They all return QString except startMSecFromCueID()
// 3 Cue ID generators: getCueID(), getAnnCueID(), getScrollCueID()
// 1 VTT Cue generator: getVTTCueTwo()
// 1 Extractor of Start Milliseconds from a string Cue ID: startMSecFromCueID()
// 1 Painter of SMAWS staff/staves: paintStaffSMAWS()
// 1 sort-by-staff function for std::stable_sort(): elementLessThanByStaff()
//
// Cue IDs -> Start & End | Ticks & Time:
// VTT needs start & end times, and I need ticks to calculate time.
// cue_id is what links the SVG elements to the VTT cues.
// It is a unique id because it is in this format:
//     "startTick_endTick"
// and startTick + endTick (duration) is unique to each cue, which links
// to one or more SVG Notes, BarLines, etc., across staves/voices.

// startMSecsFromCueID()
// Returns the Start Milliseconds for a Cue ID
static int startMSecsFromCueID(Score* score, QString& cue_id)
{   if (!cue_id.isEmpty())
        return qRound(score->tempomap()->tick2time(cue_id.left(CUE_ID_FIELD_WIDTH).toInt()) * 1000);
    else
        return 0;
}

// getCueID()
// Creates a cue ID string from a start/end tick value pair
static QString getCueID(int startTick, int endTick = -1)
{
    // For cue_id formatting: 1234567_0000007
    const int   base       = 10;
    const QChar fillChar   = '0';

    // Missing endTick means zero duration cue, only one value required
    if (endTick < 0)
        endTick = startTick;

    return QString("%1_%2").arg(startTick, CUE_ID_FIELD_WIDTH, base, fillChar)
                             .arg(endTick, CUE_ID_FIELD_WIDTH, base, fillChar);
}
// getAnnCueID()
// Gets the cue ID for an annotation, such as rehearsal mark or chord symbol,
// where the cue duration lasts until the next element of the same type.
static QString getAnnCueID(Score* score, const Element* e, EType eType)
{
    Segment* segStart = static_cast<Segment*>(e->parent());
    int     startTick = segStart->tick();

    for (Segment* seg = segStart->next1MM(Segment::Type::ChordRest);
                  seg; seg = seg->next1MM(Segment::Type::ChordRest)) {
        for (Element* eAnn : seg->annotations()) {
            if (eAnn->type() == eType)
                return getCueID(startTick, seg->tick());
        }
    }

    // If there's no "next" annotation, this is the last one in the score
    return getCueID(startTick, score->lastSegment()->tick());
}
// getScrollCueID()
// Gets the cue ID for zero-duration (scrolling) cues + rehearsal marks:
//  - ruler: BarLine or RehearsalMark
//  - frozen pane: Clef, KeySig, TimeSig, Tempo, InstrumentName, InstrumentChange
static QString getScrollCueID(Score* score, const Element* e)
{
    QString cue_id = "";
    EType   eType  = e->type();

    // Always exclude invisible elements, except TEMPO_TEXT + INSTRUMENT_CHANGE
    if (!e->visible() && (eType != EType::TEMPO_TEXT
                       || eType != EType::INSTRUMENT_CHANGE))
        return cue_id;

    Element* p = e->parent();
    switch (eType) {
    case EType::BAR_LINE       :
        // There are N + 1 BarLines per System
        //     where N = number-of-measures-in-this-system
        //    (# of barlines/system is variable, not fixed)
        // Each Measure has only 1 BarLine, at its right edge (end-of-measure)
        // Each System's first BarLine is a System BarLine  (parent == System)
        switch (p->type()) {
        case EType::SYSTEM  :
            // System BarLines only used for scrolling = zero duration
            // System::firstMeasure() has the tick we need
            cue_id = getCueID(static_cast<System*>(p)->firstMeasure()->tick());
            break;
        case EType::SEGMENT :
            // Measure BarLines are also zero duration, used for scrolling
            // and the rulers' playback position cursors.
            // RehearsalMarks only animate in the ruler, not in the score,
            // and they have full-duration cues, marker-to-marker.
            cue_id = getCueID(static_cast<Measure*>(p->parent())->tick());
            break;
        default:
            break; // Should never happen
        }
        break;
    case EType::REHEARSAL_MARK :
        cue_id = getAnnCueID(score, e, eType);
        break;
    case EType::TEMPO_TEXT :
    case EType::CLEF       :
    case EType::KEYSIG     :
    case EType::TIMESIG    :
        cue_id = getCueID(static_cast<Segment*>(p)->tick());
        break;
    case EType::INSTRUMENT_NAME :
        cue_id = CUE_ID_ZERO;
        break;
    case EType::INSTRUMENT_CHANGE :
        cue_id = getCueID(static_cast<const InstrumentChange*>(e)->segment()->tick());
        break;
    default: // Non-scrolling element types return an empty cue_id
        break;
    }

    return cue_id;
}

// getVTTCueTwo()
// Gets the first two lines of a VTT cue. The minimum valid cue requires only
// an additional newline. Some cues have cue text in addition to that.
static QString getVTTCueTwo(const QString& cue_id, const TempoMap* tempos)
{
    // Calculate start/end times ...try to imagine it as two lines of code.
    const int   startTick = cue_id.left( CUE_ID_FIELD_WIDTH).toInt();
    const int     endTick = cue_id.right(CUE_ID_FIELD_WIDTH).toInt();
    const int   startMSec = qRound(tempos->tick2time(startTick) * 1000);
    const int     endMSec = qRound(tempos->tick2time(  endTick) * 1000);
    const QTime startTime = QTime::fromMSecsSinceStartOfDay(startMSec);
    const QTime   endTime = QTime::fromMSecsSinceStartOfDay(  endMSec);

    // Return the cue's first two lines:     0000000_1234567
    //                                       00:00:00.000 --> 12:34:56.789
    return QString("%1\n%2 --> %3\n").arg(cue_id)
                                     .arg(startTime.toString("hh:mm:ss.zzz"))
                                     .arg(  endTime.toString("hh:mm:ss.zzz"));
}

// This gets used a couple/few times
static QString smawsDesc() {
    return QString(SMAWS_DESC_STUB).arg(QDate::currentDate().year())
                                   .arg(VERSION)
                                   .arg(SMAWS_VERSION);
}

// Paints the animated elements specified in the SVGMaps
static void paintStaffSMAWS(Score*        score,
                            QPainter*     p,
                            SvgGenerator* printer,
                            SVGMap*       mapFrozen,
                            SVGMap*       mapSVG,
                            QVector<int>* pVisibleStaves =  0, // only used if (!isMulti)
                            int           idxStaff = -1,       // Only used if (isMulti), visible-staff index, not Element::staffIdx()
                            bool          isMulti  = false)
{
    QString cue_id;

    // 2nd pass: Animated elements
    // Animated elements are sorted in playback order by their QMaps.
    // mapFrozen goes first, if it has any contents
    if (mapFrozen->size() > 0) {
        // Iterate by key, then by value in reverse order. This recreates the
        // MuseScore draw order within the key/cue_id. This is required for
        // the frozen pane to generate properly.
        QStringList keys = mapFrozen->uniqueKeys();
        for (QStringList::iterator c = keys.begin(); c != keys.end(); ++c) {
            printer->setCueID(*c);
            QList<const Element*> values = mapFrozen->values(*c);
            for (int i = values.size() - 1; i > -1; i--) {
                const Element* e = values[i];
                if (!isMulti)
                    printer->setStaffIndex(pVisibleStaves->value(e->staffIdx()));
                printer->setElement(e);
                paintElement(*p, e);
            }
            // Complete one frozen pane def: if (idxStaff == -1) by cue_id
            //                               else      by staff, by cue_id
            printer->freezeIt(idxStaff);
        }
    }

    // mapSVG (in reverse draw order, not a problem for these element types)
    for (SVGMap::iterator i = mapSVG->begin(); i != mapSVG->end(); ++i) {
        cue_id = i.key();
        printer->setCueID(cue_id);
        printer->setStartMSecs(startMSecsFromCueID(score, cue_id));
        printer->setElement(i.value());
        paintElement(*p, i.value());
    }

    // Close any pending Multi-Select Staves group element
    if (isMulti)
        printer->endMultiGroup();
}

// Helps sort elements on a page by element type, by staff
static bool elementLessThanByStaff(const Element* const e1, const Element* const e2)
{
    return e1->staffIdx() <= e2->staffIdx();
}

// Formats ints in fixed width for SVT attribute value
static QString formatInt(const QString& attr,
                         const int      i,
                         const int      maxDigits,
                         const bool     withQuotes)
{
    const int w = maxDigits + withQuotes ? 2: 0;
    QString qsI = QString::number(i);

    QString qs;
    QTextStream qts(&qs);

    qts << attr;
    qts.setFieldAlignment(QTextStream::AlignRight);
    qts.setFieldWidth(w);
    if (withQuotes)
        qts << QString("%1%2%3").arg(SVG_QUOTE).arg(qsI).arg(SVG_QUOTE);
    else
        qts << QString("%1").arg(qsI);

    return qs;
}


///////////////////////////////////////////////////////////////////////
// 3 SMAWS file generators: saveVTT(), saveSMAWS(), saveSMAWS_Rulers()
//
// saveVTT()
// Private, static function called by saveSMAWS() (...and saveSMAWS_Rulers()?)
// Generates the WebVTT file (.vtt) using the setVTT arg as the data source.
static bool saveVTT(Score* score, const QString& fileRoot, QStringList& setVTT)
{
    // Open a stream into the file
    QFile fileVTT;
    fileVTT.setFileName(QString("%1%2").arg(fileRoot).arg(EXT_VTT));
    fileVTT.open(QIODevice::WriteOnly | QIODevice::Text);  // TODO: check for failure here!!!
    QTextStream streamVTT(&fileVTT);

    // Stream the header
    streamVTT << VTT_HEADER;

    // Change setVTT into a sorted set of unique cue IDs, then iterate over it
    setVTT.removeDuplicates();
    setVTT.sort();
    const TempoMap* tempos = score->tempomap();
    for (int i = 0, n = setVTT.size(); i < n; i++) {
        // Stream the cue: cue_id
        //                 startTime --> endTime
        //                [this line intentionally left blank, per WebVTT spec]
        streamVTT << getVTTCueTwo(setVTT[i], tempos) << endl;
    }
    // Write and close the VTT file
    streamVTT.flush();
    fileVTT.close();
    return true;
}

// MuseScore::saveSMAWS() - one SVG file: with Cue IDs in data-cue attribute
//                          one VTT file: linked to the score SVG file and
//                          also linked to Bars and Markers (rulers) SVG files.
//    + if scroll-axis = x: one Frozen Pane SVG file: qfi->filePath()_frz.svg
//
// isMulti == Multi-Select Staves feature:
// isMulti argument outputs each staff as a separate group element in the defs
// section of the SVG file. The body of the file contains a <use> element for
// each visible staff. isMulti assumes horizontal scrolling. An extra "system"
// staff is added for chord symbols, markers, system text, measure numbers.
//
// Warning!!!
// With the page settings option for points/pixels, rounding is not an issue.
// But you must choose that option, otherwise rounding errors persist due
// to the default templates being in mm (or inches, either way).
//
bool MuseScore::saveSMAWS(Score* score, QFileInfo* qfi, bool isMulti)
{
    // qfi is a VTT file, this needs an SVG file
    const QString fileRoot = qfi->filePath().left(qfi->filePath().size() - 4);
    const QString fileSVG  = QString("%1%2").arg(fileRoot).arg(EXT_SVG);

    // Initialize MuseScore SVG Export variables
    SvgGenerator printer;
    QPainter p;
    if (!svgInit(score, fileSVG, &printer, &p, true))
        return false;

    // Custom SMAWS header, including proper reference to MuseScore
    printer.setDescription(smawsDesc());

    // The link between an SVG elements and a VTT cue. See getCueID().
    QString cue_id;

    // QSet is unordered, QStringList::removeDuplicates() creates a unique set.
    // setVTT     - a chronologically sorted set of unique cue_ids
    QStringList setVTT;

    // mapSVG    - a real map: key = cue_id; value = list of elements.
    // mapFrozen - ditto, but for frozen pane elements
    // mapMulti  - ditto, but for multi-select staves: tempos, chords, markers
    SVGMap mapSVG;
    SVGMap mapFrozen;
    SVGMap mapMulti;

    // Animated elements in a multi-page file? It's unnecessary IMO.
    // + saveSvg() handles pages in SVG with a simple horizontal offset.
    // + SVG doesn't even have support for pages, per se (yet?).
    // So this code only exports the score's first page. At least for now...
    // also note: MuseScore plans to export each page as a separate file.
    Page* page = score->pages()[0];

    // General SMAWS
    printer.setSMAWS();
    printer.setCueID("");

    // isScrollVertical determines the data-scroll attribute value:
    //   true: data-scroll="y"   false: data-scroll="x"
    // Using PageFormat::twosided() is a hack, but it causes no conflicts.
    // MuseScore's landscape vs. portrait is purely based on page dimensions
    // and doesn't exist outside of the pagesettings.ui window.
    const bool isScrollVertical = score->pageFormat()->twosided();
    printer.setScrollAxis(isScrollVertical);

    // visibleStaves - Frozen Panes and Multi-Select Staves deal with visible
    // staves only. This vector is the same size as score->nstaves(). If a
    // staff is invisible its value in the vector is -1, else it contains the
    // visible-staff index for that staff.
    QVector<int> visibleStaves;
    visibleStaves.resize(score->nstaves());
    int nVisible = 0;
    for (int i = 0; i < score->nstaves(); i++)
        visibleStaves[i] = score->staff(i)->invisible() ? -1 : nVisible++;
    printer.setNStaves(nVisible);

    // The sort order for elmPtrs is critical: if (isMulti) by type, by staff;
    //                                         else         by type;
    QList<Element*> elmPtrs = page->elements();
    std::stable_sort(elmPtrs.begin(), elmPtrs.end(), elementLessThan);
    if (isMulti) {
        std::stable_sort(elmPtrs.begin(), elmPtrs.end(), elementLessThanByStaff);
        printer.streamDefs(); // Multi-Select Staves = all content inside defs
    }
    else // Paint staff lines once, prior to painting anything else
        paintStaffLines(score, &p, &printer, page, &visibleStaves);

    QStringList      iNames;    // Only used by Multi-Select Staves.
    QList<qreal>     staffTops; // ditto
    int              idxStaff;  // Everything is grouped by staff.
    EType            eType;     // Everything is determined by element type.
    const ChordRest* cr;        // It has start and end ticks for highlighting.

    idxStaff = -1;
    foreach (const Element* e, elmPtrs) {
        // Always exclude invisible elements from this pass, except TEMPO_TEXT.
        if (!e->visible() && eType != EType::TEMPO_TEXT)
                continue;

        const int idx = e->staffIdx();
        if (isMulti && idxStaff != idx) {
            if (idxStaff > -1) {
                // Paint the previous staff's animated elements
                paintStaffSMAWS(score, &p, &printer, &mapFrozen, &mapSVG,
                                &visibleStaves, visibleStaves[idxStaff], isMulti);
                mapFrozen.clear();
                   mapSVG.clear();
            }
            // We're starting s new staff, paint its staff lines
            paintStaffLines(score, &p, &printer, page, &visibleStaves,
                            idx, isMulti, &iNames, &staffTops);
            idxStaff = idx;
        }

        // Paint inanimate elements and collect animated elements.
        // Ruler elements (BarLines and RehearsalMarks) get special treatment.
        eType = e->type();
        switch (eType) {
        case EType::STAFF_LINES :   /// Not animated, but handled previously.
            continue;
            break;
                                    /// Highlighted Elements:
        case EType::REST       : //                = ChordRest subclass Rest
        case EType::LYRICS     : //         parent = ChordRest
        case EType::NOTE       : //         parent = ChordRest subclass Chord
        case EType::NOTEDOT    : //   grand-parent = ChordRest subclass Chord
        case EType::ACCIDENTAL : //   grand-parent = ChordRest subclass Chord
            switch (eType) {
            case EType::REST :
                cr = static_cast<const ChordRest*>(e);
                break;
            case EType::LYRICS :
            case EType::NOTE   :
                cr = static_cast<const ChordRest*>(e->parent());
                break;
            case EType::NOTEDOT    :
            case EType::ACCIDENTAL :
                cr = static_cast<const ChordRest*>(e->parent()->parent());
                break;
            default:
                break; // should never happen
            }
            cue_id = getCueID(cr->tick(),
                              cr->tick() + cr->actualTicks());
            setVTT.append(cue_id);
            mapSVG.insert(cue_id, e);
            continue;
            break;

        case EType::HARMONY :    // Highlighted until next HARMONY
            cue_id = getAnnCueID(score, e, eType);
            setVTT.append(cue_id);
            if (isMulti)
                mapMulti.insert(cue_id, e);
            else
                mapSVG.insert(cue_id, e);
            continue;
            break;

        case EType::TEMPO_TEXT        : /// Frozen Pane elements
        case EType::INSTRUMENT_NAME   :
        case EType::INSTRUMENT_CHANGE :
        case EType::CLEF    :
        case EType::KEYSIG  :
        case EType::TIMESIG :
            if (!isScrollVertical) {
                // Zero-duration cue
                cue_id = getScrollCueID(score, e);
                // insert into mapSVG and setVTT
                setVTT.append(cue_id);
                if (isMulti && eType == EType::TEMPO_TEXT)
                    mapMulti.insert(cue_id, e);
                else
                    mapFrozen.insert(cue_id, e);
                continue;
            }
            else
                cue_id = ""; // vertical scrolling: these elements not animated
            break;

        case EType::BAR_LINE       :    /// Ruler elements
        case EType::REHEARSAL_MARK :
            // Add the cue ID to the VTT set.
            cue_id = getScrollCueID(score, e);
            setVTT.append(cue_id);
            if (isMulti && eType == EType::REHEARSAL_MARK) {
                mapMulti.insert("", e); // no cue id in music svg file
                continue;
            }
            break;

        case EType::TEXT       :
        case EType::STAFF_TEXT : {
            TextStyleType tst = static_cast<const Text*>(e)->textStyleType();
            if (isMulti && (tst == TextStyleType::MEASURE_NUMBER
                         || tst == TextStyleType::SYSTEM)) {
                cue_id = "";
                mapMulti.insert(cue_id, e);
                continue;
            }
            break;}

        default:                        /// Un-animated (inanimate?) elements
            cue_id = "";
            break;
        }

        // Set the Element pointer inside SvgGenerator/SvgPaintEngine
        printer.setElement(e);

        // Custom data-start attribute = start time in whole milliseconds.
        // Elements with the onClick event need it. Yes, it semi-duplicates
        // the cue id, but not totally. Some elements have a cue_id, but no
        // data-start attribute, because they are not clickable in the score.
        // RehearsalMarks have a data-start, but no cue id, because I prefer
        // not to highlight them in the score (at least for now), but they
        // are clickable in the Markers timeline ruler.
        printer.setStartMSecs(startMSecsFromCueID(score, cue_id));

        // RehearsalMarks only animate in the Ruler, not in the score.
        // Same VTT file, different SVG file. See saveSMAWS_Rulers().
        if (eType == EType::REHEARSAL_MARK)
            cue_id = "";

        // Set the cue_id, even if it's empty (especially if it's empty)
        printer.setCueID(cue_id);

        // Paint the (un-animated) element
        paintElement(p, e);
    }

    if (isMulti) {
        // Paint the last staff's animated elements
        paintStaffSMAWS(score, &p, &printer, &mapFrozen, &mapSVG,
                        &visibleStaves, visibleStaves[idxStaff], isMulti);

        // Paint the staff-independent elements
        iNames.append("system");
        printer.setStaffIndex(nVisible); // only affects fancy formatting
        printer.setYOffset(0);
        printer.beginMultiGroup(&iNames, "system", 0, 0);
        for (SVGMap::iterator i = mapMulti.begin(); i != mapMulti.end(); ++i) {
            cue_id = i.key();
            printer.setCueID(cue_id);
            printer.setStartMSecs(startMSecsFromCueID(score, cue_id));
            printer.setElement(i.value());
            paintElement(p, i.value());
        }
        printer.endMultiGroup();

        // Multi-Select Staves has <use> elements, one per staff, in the body
        staffTops.append(staffTops[0]); // For the staff-independent elements
        printer.streamBody();
        for (int i = 0; i < iNames.size(); i++)
            printer.createMultiUse(iNames[i], staffTops[i] - staffTops[0]);
    }
    else // Paint everything all at once, not by staff
        paintStaffSMAWS(score, &p, &printer, &mapFrozen, &mapSVG, &visibleStaves);

    // The bars ruler is based around the concept of start-of-bar lines, so it
    // has a line for the imaginary bar on the other side of the final BarLine.
    // That ruler line has this Cue ID:
    setVTT.append(getCueID(score->lastSegment()->tick()));

    // Write the VTT file
    if (!saveVTT(score, fileRoot, setVTT))
        return false;

    // Clean up and return
    score->setPrinting(false);
    MScore::pdfPrinting = false;
    p.end(); // Writes MuseScore (and Frozen) SVG file(s) to disk, finally
    return true;
}

// MuseScore::saveSMAWS_Rulers()
//-Generates the BarLine and RehearsalMarker rulers for the playback timeline.
//-This is best generated from a single-staff, horizontally scrolling, one-page
// score. That way there is only one system BarLine, at the start of the score,
// and only one BarLine per measure. That way I don't have to code for multiple
// systems/staves in order to prevent duplicate SVG elements in the file.
//-Currently this only generates two SVG files, zero VTT files. But a separate
// file for the ruler cues might be useful in the future.
bool MuseScore::saveSMAWS_Rulers(Score* score, QFileInfo* qfi)
{
    // This is a long, tedious function, with lots of constant values. It
    // generates two SVG files, once per composition. The VTT is generated by
    // saveSMAWS() when exporting each part and/or score for that composition.
    //
    // In MuseScore, a Measure's Barline is the line at the end of the bar.
    // No one thinks of bar numbers as the end-barline. If I click on a barline
    // in the bars ruler, I expect to hear the start of that bar, not the end.
    // This means there's an extra bar # in every score's bars ruler for the
    // last bar that has no music, but is the end of the song.
    // First/last ruler line text is left/right aligned, not centered.
    //
    // Deal with bars ruler line density? No. The more bars per score, the less
    // space between lines. For scores beyond a certain length, the ruler will
    // need to have 1 line for every 2 or more bars. For now, my scores are
    // not long enough to reach this limit, so I'm not going to code for it.
    // For now: the bars ruler is 1:1, lines:bars.
    //
    // Short vs long lines every how many bars? Long every 5, Label every 10.
    // This is reflected in the value of a line's y2 attribute.

    // Constants and Variables:
    // Strings for the ruler's <line> and <text> element attributes
    QString label;  // <text> element contents

    QString y;      // y = one of these two values, depending on element type
    const QString yBars       = " y=\"18\"";
    const QString yMarks      = " y=\"17\"";

    QString anchor; // only anchorEnd is used for now
    const QString anchorStart = " style=\"text-anchor:start\"";
    const QString anchorEnd   = " style=\"text-anchor:end\"";

    // Boilerplate headers, borders, and cursors
    const QString hdrBars     = "<?xml-stylesheet type=\"text/css\" href=\"SMAWS_21.css\" ?>\n<svg width=\"1360\" height=\"20\" cursor=\"default\" pointer-events=\"visible\" xmlns=\"http://www.w3.org/2000/svg\">\n\n";
    const QString hdrMarks    = "<?xml-stylesheet type=\"text/css\" href=\"SMAWS_21.css\" ?>\n<svg width=\"1360\" height=\"20\" cursor=\"default\" pointer-events=\"visible\" xmlns=\"http://www.w3.org/2000/svg\"\n data-attr=\"fill\">\n\n";
    const QString border      = "<rect class=\"border\" x=\"0.5\" y=\"0.5\" width=\"1359\" height=\"19\"/>\n";
    const QString grayRect    = "<rect class=\"gray\"   x=\"0\"   y=\"1\"   width=   \"0\" height=\"18\" fill=\"none\"/>\n";
    const QString cursorBars  = "<polygon class=\"cursor\" points=\"-6,1 6,1 0,12\" transform=\"translate(8,0)\"/>\n";
    const QString cursorMarks = "<polygon class=\"cursor\" points=\"-6,19 6,19 0,7\" transform=\"translate(8,0)\"/>\n";

    // For CSS Styling
    QString classVal;
    const QString classRul  = "ruler\" ";
    const QString classRul5 = "ruler5\"";
    const QString classMrkr = "marker\"";

    // Event handler for clicking on ruler lines/text
    const QString onClick = " onclick=\"top.clickRuler(evt)\"";

    // Default width of rulers = 1600 - 240 for counters (1600x900 = 16:9)
    const int wRuler = 1360;
    // Ruler lines don't start at zero or end at wRuler, left=right margin
    const int margin = 8;
    // Score::duration() returns # of seconds as an int, I need more accuracy
    const TempoMap* tempos = score->tempomap();
    const qreal duration = tempos->tick2time(score->lastMeasure()->tick()
                                           + score->lastMeasure()->ticks());
    // Pixels of width per millisecond
    const qreal pxPerMSec = (wRuler - (margin * 2)) / (duration * 1000);
    // This procedure opens files in only one mode
    const QIODevice::OpenMode openMode = QIODevice::WriteOnly | QIODevice::Text;
    // The root file name, without the .ext
    const QString fileRoot = qfi->filePath().left(qfi->filePath().size() - 4);

    qreal   pxX;      // Floating point version of x coordinates
    qreal   offX;     // x offset for rehearsal mark text
    int     iY1, iY2; // Integer version of y1 and y2 coordinates
    int     iBarNo;   // Integer version of measure number
    QString fn;       // file name

    // 2 rulers = 2 SVG files
    QFile fileBars;  // Bar|Beat, but only bars in the ruler. Beats in a counter?
    QFile fileMarks; // Rehearsal marks

    fn = QString("%1_%2%3").arg(fileRoot).arg("bars").arg(EXT_SVG);
    fileBars.setFileName(fn);
    fileBars.open(openMode);  // TODO: check for failure here!!!
    QTextStream streamBars(&fileBars);

    fn = QString("%1_%2%3").arg(fileRoot).arg("mrks").arg(EXT_SVG);
    fileMarks.setFileName(fn);
    fileMarks.open(openMode);  // TODO: check for failure here!!!
    QTextStream streamMarks(&fileMarks);

    // Stream the headers, borders, template "gray-out" rect, and cursors
    streamBars  << hdrBars;
    streamMarks << hdrMarks;
    streamBars  << border;
    streamMarks << border;
    streamBars  << grayRect;
    streamMarks << grayRect;
    streamBars  << cursorBars;
    streamMarks << cursorMarks;
    // Display floating point numbers with consistent precision
    streamBars.setRealNumberPrecision(SVG_PRECISION);
    streamBars.setRealNumberNotation(QTextStream::FixedNotation);
    streamMarks.setRealNumberPrecision(SVG_PRECISION);
    streamMarks.setRealNumberNotation(QTextStream::FixedNotation);

    // Collect the ruler elements
    // Not a multimap, rehearsal marks must be spaced >1 measure apart.
    QMap<QString, const Element*> mapRulersSVG;
    QString cue_id;
    foreach (Page* page, score->pages()) {
        QList<Element*> pel = page->elements();
        qStableSort(pel.begin(), pel.end(), elementLessThan);

        foreach (const Element* e, pel) {
            // We're only looking for a few element types
            switch (e->type()) {
            case EType::BAR_LINE       :
            case EType::SYSTEM         : // The first barline in any system
            case EType::REHEARSAL_MARK :
                break;
            default:
                continue;
            }
            cue_id = getScrollCueID(score, e);
            if (!cue_id.isEmpty())
                mapRulersSVG[cue_id] = e;
        }
    }
    // The bar lines ruler has a final, extra line, and maybe text.
    cue_id = getCueID(score->lastSegment()->tick());
    mapRulersSVG[cue_id] = static_cast<const Element*>(score->lastSegment());

    // Tick/Time variables: end tick/time and duration don't apply here
    int     startTick;
    int     startMSec;
    QString dataStart;

    // For the invisible, but clickable, rects around lines
    qreal   rectX = 0;
    qreal   lineX;
    QString prevStart;

    // Stream the line and text elements, with all their attributes:
    //   cue_id, x, x1, x2, y, y1, y2, anchor, and label
    // y and y1 are fixed by element type. That leaves:
    // cue_id, x, x1, x2, y2, anchor and label
    for (QMap<QString, const Element*>::iterator i  = mapRulersSVG.begin();
                                                 i != mapRulersSVG.end();
                                                 i++) {
        // Default Values:
        // x = x1 = x2, they're all the same: a vertical line or centered text.
        // The exception is x for rehearsal mark text, which is offset right.
        // Y values are varied, but with a limited set of values, by EType.
        iY1    = 1;
        iY2    = 9;
        offX   = 0;
        label  = "";
        anchor = "";
        classVal = classRul;

        // Values for this cue
        cue_id = i.key();
        startTick = cue_id.left(CUE_ID_FIELD_WIDTH).toInt();
        startMSec = startMSecsFromCueID(score, cue_id);
        pxX = margin + (startMSec * pxPerMSec);
        dataStart = QString("%1%2%3").arg(SVG_START).arg(startMSec).arg(SVG_QUOTE);

        qreal   width, x;
        QString start;
        const Element* e = i.value();
        EType eType = e->type();
        switch (eType) {
        case EType::BAR_LINE :
        case EType::SEGMENT  : // Final, extra line in Bars ruler
            if (eType == EType::BAR_LINE)
                iBarNo = static_cast<Measure*>(e->parent()->parent())->no() + 1;
            else
                iBarNo++; // That imaginary bar on the other side of the final BarLine

            if (iBarNo % 5 == 0) {
                // Multiples of 5 get a longer, thick line
                iY2 = 13;
                classVal = classRul5;
                if (iBarNo % 10 == 0) {
                    // Multiples of 10 get text and a shorter, thick line
                    iY2 = 4;
                    label = QString("%1").arg(iBarNo);
                }
            }
            if (startTick > 0) {
                x = rectX;
                width = pxX - ((pxX - lineX) / 2) - rectX;
                start = prevStart;
            }
            y    = yBars;
            break;
        case EType::REHEARSAL_MARK :
            y     = yMarks;
            iY1   =  7;
            iY2   = 19;
            offX  =  6;
            x     = pxX - offX;
            width = offX * 2;
            label = static_cast<const Text*>(e)->xmlText();
            start = dataStart;
            classVal = classMrkr;
            break;

        default:
            break;
        }
        // Ruler lines have invisible rects around them, allowing users to be
        // less precise with their mouse clicks. The last BarLine ruler line
        // is excluded, because it's not clickable.
        // The code operates on the current Marker and the previous BarLine.
        // Marker rects have a fixed width rect = text offset from line.
        // BarLine rects split the space around each line, no empty spaces.
        const bool  isMarker = (eType == EType::REHEARSAL_MARK);
        QTextStream* streamX = isMarker ? &streamMarks : &streamBars;
        if (isMarker || startTick > 0) {
            if (isMarker)
                *streamX << endl;

            *streamX << SVG_RECT << onClick   << start
                        << SVG_X << SVG_QUOTE << x        << SVG_QUOTE
                        << SVG_Y << SVG_QUOTE << iY1      << SVG_QUOTE
                        << SVG_WIDTH          << width    << SVG_QUOTE
                        << SVG_HEIGHT         << "18"     << SVG_QUOTE
                        << SVG_FILL           << SVG_NONE << SVG_QUOTE
                     << SVG_ELEMENT_END << endl;

            if (!isMarker)
                rectX += width;
        }
        if (!isMarker) {
            *streamX << endl;
            lineX = pxX;
            prevStart = dataStart;
        }
        *streamX << SVG_LINE      << onClick   << dataStart
                    << SVG_CUE    << cue_id    << SVG_QUOTE
                    << SVG_CLASS  << classVal
                    << SVG_X1     << pxX       << SVG_QUOTE
                    << SVG_Y1     << iY1       << SVG_QUOTE
                    << SVG_X2     << pxX       << SVG_QUOTE
                    << SVG_Y2     << iY2       << SVG_QUOTE
                    << SVG_STROKE << SVG_BLACK << SVG_QUOTE
                 << SVG_ELEMENT_END << endl;

        // Only stream the text element if there's text inside it
        if (!label.isEmpty()) {
            *streamX << SVG_TEXT_BEGIN << onClick    << dataStart
                        << SVG_CUE     << cue_id     << SVG_QUOTE
                        << SVG_CLASS   << classVal
                        << SVG_X       << SVG_SPACE  << SVG_QUOTE
                                       << pxX + offX << SVG_QUOTE
                        << y << anchor << SVG_GT     << label
                     << SVG_TEXT_END << endl;
        }
    } //for (i)
    // Stream the "footer", terminating the <svg> element
    streamBars  << SVG_END;
    streamMarks << SVG_END;
    // Flush streams, close files, and return
    streamBars.flush();
    streamMarks.flush();
    fileBars.close();
    fileMarks.close();
    return true;
}

//
// SMAWS HTML and SVG Tables generator
//
bool MuseScore::saveSMAWS_Tables(Score* score, QFileInfo* qfi, bool isHTML)
{
    // A single score can have multiple tables, just as a single HTML page can
    // have multiple tables.  In MuseScore I'm using the repeat barlines as a
    // 1)separator and
    // 2)loop vs. pick-up/count-off indicator.
    // There are three types of repeat barlines: Left, Right, and Both.
    // This code uses the Measure class's have a Repeat Flag to get that data.

    // Pitch is 100% irrelevant at this time, as are multiple notes/voices in
    // a staff's ChordRest. All that matters is: note duration per staff.
    // Pitch and more could definitely become useful when this gets hooked up
    // to MIDI on the client end. Not yet...

    // I handle pick-up measures (Repeat::NONE), but not let-downs. No need yet.

    // Every SMAWS HTML Table's columns are defined by the length of the repeat
    // segment and the grid density. I'm using the convention that the first
    // and only small-size staff defines the grid.
    //
    // I also always name that staff "grid", but it's not required by the code.
    //
    // This grid staff contains notes, no rests, for the length of each repeat.
    // Anywhere you want to make a table column, put a note in the grid staff.
    // Generally within a table, the grid is one duration (e.g. 1/8th notes)
    // for the entire table.  But it is plausible in a Chords table to need a
    // mainly 1-bar grid that has 1/2 bar columns for mid-bar chord changes.
    // If barline borders are different than intra-bar borders, this is OK.
    // Sub-dividing the grid with extra <td>s in a column doesn't work easily.
    // Implementation is a colspan in the grid row + extra column(s) in table.
    // I'm not implementing it (yet). No pressing need, may never arise...
    // For now sub-divisions of the grid by staff are considered an error.

    // The order of the staves top-to-bottom == the order of the rows
    // Staff == Row, Time/Beat == Column
    // Extra header column for intrument names (row headers)
    // Extra pseudo-header columns for pick-up/count-off

    // For SVG, x-axis = columns, y-axis = rows: Columns move left-to-right
    //                                              Rows move top-to-bottom
    // It's totally backwards from the standard spreadsheet row/column concept.
    // Think about it this way: row data is across the columns
    //                          col data is across the rows
    // It gets into reverse translating from data cells to for loop iteration.

    // Total staves, including invible and temporarily invisible staves
    const int nStaves = score->nstaves();

    // Iterate by Staff to locate the grid staff
    int idxGrid;
    int idxStaff;
    for (idxStaff = 0; idxStaff < nStaves; idxStaff++) {
        if (score->staff(idxStaff)->small()) {
            idxGrid = idxStaff;
            break;
        }
    }
    if (idxStaff == nStaves) // no grid staff ==
        return false; // no go

    int startOffset = 0; // this repeat's  start tick
    int startTick   = 0; // this chord's   start tick, relative to this repeat
    int mStartTick  = 0; // this measure's start tick, relative to this repeat
    int mTicks      = 0; // this measure's     actual ticks (duration)
    int dataTicks   = 0; // this chord's       actual ticks
    int gridTicks   = 0; // this grid column's actual ticks (duration)
    int gridTick    = 0; // this grid column's un-offset tick value = cr.tick()
    int pageTick    = 0; // this page's endTick == next page's mStartTick
    int idxPage     =-1; // this page's page index (page number minus one)
    int idxCol      = 0; // if (isPages) the current column index
    int idxBar      = 0; // ditto, bar line index
    int idxBeat     = 0; // ditto, grid line index
    int nTables     = 0; // if (tableTitle.isEmpty()) unique, numbered titles;

    Measure*   m;        // this measure
    Segment*   s;        // this segment
    ChordRest* crGrid;   // this start tick's ChordRest from the grid staff
    ChordRest* crData;   // this start tick's ChordRest from this staff

    QTextStream     qts;        // temp variable used to populate grid and more
    QString*        pqs;        //  ditto
    StrPtrList*     spl;        //  ditto
    StrPtrVect*     spv;        //  ditto
    StrPtrListVect* splv;       //  ditto...
    IntList*        pil;        // temp variable for pitches/ordinals
    IntListVect*    pilv;       // ditto
    QString         cue_id;     // temp variable for cue_id
    QString         page_id;    // ditto for page cue_id
    QString         tableTitle; // RehearsalMark at startTick==0 is the title

    QStringList    tableCues;  // List of cue_ids for VTT file
    StrPtrList     barLines;   // List of <line>s
    StrPtrList     beatLines;  // Every whole beat (1/4 note in 4/4 time)
    StrPtrList     gridUse;    // if (isPages) this is for grid staff
    StrPtrList     gridText;   //  ditto
    StrPtrVectList grid;       // List = columns/beats. Vector = rows/staves
    StrPtrVectList dataCues;   // data-cue only in cells that have >0 cue_ids

    // Bar and Beat Line x-coordinates per page:
    IntListList    pageBars;     // for/by barline
    IntListList    pageBeats;    // for/by beatline

    // things by page:
    IntList        pageCols;     // active column count per page
    StrPtrListList pageGridText; // grid row innerHTML, by column
    StrPtrVectList pageNames;    // instrument name text, by row
    StrPtrVectList pageStyles;   // instrument name style: Lo or No, by row
    StrPtrListVectList leds;     // data cell href   by col, by row, by page
    IntListVectList    pitches;  // MIDI note number by col, by row, by page

    IntListVect  pitchSet(nStaves, 0); // by row: sorted, unique set of MIDI note numbers
    StrPtrVect     iNames(nStaves, 0); // Row header instrument names

    // Pages are repeated patterns within a repeat ~= voltas.
    // Pages are separated by double-barlines.
    // Pages are SVG only.
    // These variables are all part of multi-page functionality:
    bool           isPages     = false;
    bool           isPageStart = false;
    Measure*       mp;         // temp variable for measure within a page
    Measure*       mPageEnd;   // this page's end measure
    QString        pageCues;   // page #: data-cue="id1,text1;id2,text2;etc."
    QStringList    pageIDs;    // just the page_ids, in order, by page

    // Constants for SVG table cell dimensions, in pixels
    const int cellWidth  =  48;
    const int cellHeight =  48;
    const int iNameWidth = 144; // Instrument names are in the left-most column
    const int maxDigits  =   4; // for x/y value formatting, range = 0-9999px

    // Variables for SVG table cell positions
    int cellX  = iNameWidth;    // fixed offset for instrument name row headers
    int cellY  = 0;
    int height = 0;

    // These are only used for barLines <rect>s and beatLines <line>s
    const int   gridMargin =  8;
    const int   barMargin  = 11;
    const int   barWidth   =  2; // <rect> acting as a bar line
    const qreal barRound   =  1; // barWidth/2 simulates stroke-linecap:round

    // For ledMini and multi-pitch rows
    const qreal ledHeight     = 40.0;
    const qreal miniHeight    = 17.0;
    const qreal verticalSpace = ledHeight - miniHeight;
    const qreal restOffset    = (ledHeight / 2) - (miniHeight / 2);

    // For xlink:href values
    const QString LED  = "led";
    const QString MINI = "ledMini";
    const QString LO   = "Lo";
    const QString NO   = "No";

    // Currently two HTML table styles, one kludgy option implementation.
    // Two styles are: tableChords and tableDrumMachine
    const QString classHTML = score->pageFormat()->twosided()
                            ? "tableChords"
                            : "tableDrumMachine";

    // Creates unique title if the score has none: << idStub << ++nTables
    // Each HTML table gets a unique id value: idStub1, idStub2, etc. !!! for now... Is it necessary?
    const QString idStub = "tblSMAWS";

    // qfi is a VTT file, this needs an SVG or HTML file too
    const QString fnRoot  = qfi->filePath().left(qfi->filePath().size() - 4);
    QString       fnTable;
    QFile         tableFile;
    QTextStream   tableStream;

    // HTML: One file contains multiple tables
    if (isHTML) {
        // Open a stream into the HTML file
        fnTable = QString("%1%2").arg(fnRoot).arg(EXT_HTML);
        tableFile.setFileName(fnTable);
        tableFile.open(QIODevice::WriteOnly | QIODevice::Text);  // TODO: check for failure here!!!
        tableStream.setDevice(&tableFile);

        // Stream the <head> and the start of the <body>
        tableStream << HTML_HEADER;
    }

    // Iterate sequentially, chronologically, left-to-right:
    //   by measure, by segment of type ChordRest, if grid staff contains chord
    for (m = score->firstMeasure(); m; m = m->nextMeasureMM())
    {
        // START == start-of-repeat or pickup bar
        // Every repeat and every pickup effectively start at tick zero
        if (m->repeatStart())
            startOffset = m->tick();

        mStartTick = m->tick() - startOffset;
        mTicks     = m->ticks();

        for (s = m->first(Segment::Type::ChordRest); s; s = s->next(Segment::Type::ChordRest))
        {
            crGrid = s->cr(idxGrid * VOICES); // The grid staff's ChordRest
            if (crGrid == 0)
                continue;

            if (crGrid->type() == EType::CHORD) {                              /// GRID CHORD ///
                if (gridTicks == 0                        //    new table
                || (isPages && pageTick == mStartTick)) { // or new page
                    if (gridTicks == 0) {                                      /// NEW TABLE ///
                        // The table's title is its first RehearsalMark's text
                        for (Element* eAnn : s->annotations()) {
                            if (eAnn->type() == EType::REHEARSAL_MARK) {
                                tableTitle = static_cast<RehearsalMark*>(eAnn)->xmlText();
                                break;
                            }
                        }
                        if (tableTitle.isEmpty()) // Numerically indexed title
                            tableTitle = QString("%1%2").arg(idStub).arg(++nTables);
                    }

                    if (isHTML) { // One pages for all the tables, one file too
                        // Stream the start of the <table> element to the file
                        tableStream << HTML_TABLE_BEGIN
                                    << SVG_ID    << tableTitle.replace(SVG_SPACE, SVG_DASH) << SVG_QUOTE
                                    << SVG_CLASS << classHTML                               << SVG_QUOTE
                                    << SVG_GT    << endl;
                    }
                    else { // SVG:\\ Deal with multiple pages, or not...
                        // Find the next double-barline or Repeat::END
                        for (mp = m; mp; mp = mp->nextMeasureMM()) {           /// NEW PAGE? ///
                            if (mp->repeatEnd()) {
                                if (isPages)            // end of table:
                                    isPageStart = true; //     only one page
                                break;                  //     or  last page
                            }
                            else if (mp->last()->isEndBarLineType()
                                  && static_cast<BarLine*>(mp->last()->element(0))->barLineType() == BarLineType::DOUBLE) {
                                isPages     = true;   // this table has pages
                                isPageStart = true;   // this cr is start-of-page
                                break;
                            }
                        }
                        if (isPageStart) {                                     /// NEW PAGE ///
                            cellX = iNameWidth; // reset horizontal position

                            // This page's last measure and endTick
                            mPageEnd = mp;
                            pageTick = mp->tick() + mp->ticks() - startOffset;

                            // This page's cue_id, for scrolling by page
                            page_id = getCueID(mStartTick);
                            tableCues.append(page_id); // add page cue to VTT

                            // List of page cue_id/pageNumber pairs
                            qts.setString(&pageCues);
                            if (pageCues.isEmpty())
                                qts << SVG_CUE;
                            else
                                qts << SVG_COMMA;
                            qts << page_id << SVG_SEMICOLON
                                << QString("%1").arg(++idxPage + 1, 2, 10, QLatin1Char(SVG_ZERO));

                            // Initialize this page's collections
                            pageCols.append(0);

                            spl = new StrPtrList;
                            pageGridText.append(spl);

                            spv = new StrPtrVect(nStaves, 0);
                            pageNames.append(spv);
                            spv = new StrPtrVect(nStaves, 0);
                            pageStyles.append(spv);
                        }
                        // Reset indices for the new table or page
                        idxCol = 0;
                        idxBeat = 0;
                        idxBar = 0;
                    } // SVG
                } // if (new table or new page);

                // This grid column's cue_id
                gridTick  = crGrid->tick();
                gridTicks = crGrid->actualTicks();
                startTick = gridTick - startOffset;
                cue_id    = getCueID(startTick, startTick + gridTicks);
                tableCues.append(cue_id);

                if (!isPages || idxCol == grid.size()) {
                    pilv = new IntListVect(nStaves, 0);
                    pitches.append(pilv);

                    if (isPages) {
                        spv = new StrPtrVect(nStaves, 0);
                        dataCues.append(spv);

                        splv = new StrPtrListVect(nStaves, 0);
                        leds.append(splv);
                    }
                    spv = new StrPtrVect(nStaves, 0);
                }
                else
                    spv = grid[idxCol];

                // Rows
                // Iterate over all the staves and collect stuff
                for (int r = 0; r < nStaves; r++) {
                    const int  track    = r * VOICES;
                    bool isStaffVisible = m->system()->staff(r)->show();

                    // Set instrument name for this row once per table
                    //                 and if (isPages) once per page
                    if (r != idxGrid
                    && ((iNames[r] == 0 && isStaffVisible) || isPageStart)) { /// INSTRUMENT NAMES ///
                        if (isPageStart && isStaffVisible) {
                            // Empty staff within a page is "invisible"
                            for (mp = m; mp; mp = mp->nextMeasureMM()) {
                                if (!mp->isOnlyRests(track))
                                    break;
                                if (mp == mPageEnd) { // empty staff for this page
                                    isStaffVisible = false;
                                    break;
                                }
                            }
                        }
                        if (iNames[r] == 0 || isPageStart) {
                            const QString style = QString("inst%1").arg(isStaffVisible ? NO : LO);
                            if (iNames[r] == 0) {
                                iNames[r] = new QString;
                                pqs = iNames[r];
                                qts.setString(pqs);
                                qts << SVG_TEXT_BEGIN
                                    << formatInt(SVG_X, cellX,                 maxDigits, true)
                                    << formatInt(SVG_Y, cellY+(cellHeight-14), maxDigits, true)
                                    << SVG_CLASS << style << SVG_QUOTE;
                            }
                            if (isPageStart) {
                                (*pageNames[idxPage])[r]  = new QString(score->staff(r)->part()->longName(gridTick));
                                (*pageStyles[idxPage])[r] = new QString(style);
                            }
                        }
                    }

                    // The ChordRest for this staff, using only Voice #1
                    crData = s->cr(track);
                    if (!isStaffVisible || crData == 0 || !crData->visible()) {/// EMPTY CELL ///
                        if (!isHTML && (isPages || isStaffVisible))
                            cellY += cellHeight;
                        if (isPages) {
                            if ((*pitches[idxCol])[r] != 0)
                                (*pitches[idxCol])[r]->append(MIDI_EMPTY);
                            if ((*leds[idxCol])[r] != 0) {
                                pqs = new QString(SVG_HASH);
                                (*leds[idxCol])[r]->append(pqs);
                            }
                        }
                        continue;
                    }

                    pqs = (*spv)[r];
                    if (!isPages || pqs == 0) {
                        pqs = new QString;
                        (*spv)[r] = pqs;
                    }
                    qts.setString(pqs);

                    if (r == idxGrid) {                                        /// GRID CELL ///
                        // Grid staff cells are simple
                        if (isHTML)
                            qts << HTML_TH_BEGIN << SVG_GT
                                << crGrid->lyrics(0)->xmlText()
                                << HTML_TH_END;
                        else {
                            // Required if the idxGrid is not the first staff
                            cue_id = getCueID(startTick, startTick + gridTicks);

                            QString ref = "grid";
                            if (isPages && idxPage > 0)
                                ref += LO;
                            else
                                ref += NO;

                            // Grid <use> element
                            if (!isPages || idxCol == gridUse.size()) {
                                qts << SVG_USE    << SVG_SPACE
                                    << formatInt(SVG_X, cellX, maxDigits, true)
                                    << formatInt(SVG_Y, cellY, maxDigits, true)
                                    << XLINK_HREF << ref    << SVG_QUOTE
                                    << SVG_CUE    << cue_id;

                                if (!isPages)
                                    qts << SVG_QUOTE << SVG_ELEMENT_END << endl;
                                else {
                                    gridUse.append(pqs);
                                    pqs = new QString;  // For grid <text>, next
                                    qts.setString(pqs);
                                }
                            }
                            else { // gridUse[idxCol] exists, append cue_id
                                qts.setString(gridUse[idxCol]);
                                qts << SVG_COMMA << cue_id;
                            }

                            // Grid <text> element
                            const QString lyrics = crGrid->lyrics(0)->xmlText();

                            if (!isPages || idxCol == gridText.size()) {
                                qts << SVG_TEXT_BEGIN
                                    << formatInt(SVG_X, cellX + (cellWidth  / 2), maxDigits, true)
                                    << formatInt(SVG_Y, cellY + (cellHeight / 2), maxDigits, true)
                                    << SVG_CLASS << ref    << SVG_QUOTE
                                    << SVG_CUE   << cue_id;

                                if (!isPages)
                                    qts << SVG_QUOTE << SVG_GT << lyrics
                                        << SVG_TEXT_END << endl;
                                else
                                    gridText.append(pqs);
                            }
                            else { // gridText[r] exists (isPages == true)
                                qts.setString(gridText[idxCol]);
                                qts << SVG_COMMA << cue_id; // Highlight cue
                            }

                            if (isPages) {
                                pageCols[idxPage]++;
                                pqs = new QString(lyrics);
                                pageGridText[idxPage]->append(pqs);
                            }

                            // Grid <line> for whole beats e,g, 1/4 note in 4/4 time
                            const int x     = cellX * (isPages && idxPage > 0 ? -1 : 1);
                            const int tick  = startTick - mStartTick;
                            const int denom = mTicks
                                            / score->staff(r)->timeSig(startTick)->sig().denominator();
                            if (tick && !(tick % denom)) {
                                if (!isPages || idxBeat == beatLines.size()) {
                                    // Initial x-coord for line: if it's not
                                    // page 1, it's invisible via negative x.
                                    pqs = new QString;
                                    qts.setString(pqs);
                                    qts << SVG_LINE
                                           << SVG_X1    << x          << SVG_QUOTE
                                           << SVG_Y1    << cellHeight
                                                         + gridMargin << SVG_QUOTE
                                           << SVG_X2    << x          << SVG_QUOTE
                                           << SVG_Y2    << height
                                                         - cellHeight
                                                         - gridMargin << SVG_QUOTE
                                           << SVG_CLASS << "beatLine" << SVG_QUOTE;
                                    if (!isPages)
                                        qts << SVG_ELEMENT_END        << endl;

                                    beatLines.append(pqs);
                                }
                                if (isPages) {
                                    if (pageBeats.size() == idxBeat) {
                                        pil = new IntList;
                                        pageBeats.append(pil);
                                    }
                                    while (pageBeats[idxBeat]->size() < idxPage)
                                        pageBeats[idxBeat]->append(x); // missing pages = invisible gridline
                                    pageBeats[idxBeat]->append(cellX);
                                    idxBeat++;
                                }
                            }
                        }
                    } // if(idxGrid)
                    else {                                                     /// DATA CELL ///
                        // Data cells are not as simple
                        dataTicks = crData->actualTicks();

                        if (dataTicks < gridTicks)
                            return false; // Dies ist verboten

                        const int  colSpan = dataTicks / gridTicks;
                        const bool isChord = (crData->type() == EType::CHORD);

                        cue_id = getCueID(startTick, startTick + dataTicks);

                        if (isHTML) {
                            // Start the <td> element
                            qts << HTML_TD_BEGIN;
                            if (colSpan > 1)
                                // Usually cells only span one column but not always.
                                // Add cue_id and colspan attributes to this <td>.
                                qts << SVG_CUE   << cue_id
                                    << SVG_QUOTE << HTML_COLSPAN << colSpan << SVG_QUOTE;
                            qts << SVG_GT;

                            // <td>content only if it's a note in this staff
                            if (isChord) {
                                const TDuration dur = crData->durationType();

                                qts << XML_ENTITY_BEGIN
                                    << QString::number(durationUnicode[int(dur.type())], 16).toUpper()
                                    << XML_ENTITY_END;

                                for (int j = 0; j < dur.dots(); j++)
                                    qts << UNICODE_DOT;
                            }
                            // Complete the <td>...</td>
                            qts << HTML_TD_END;
                        }
                        else { // SVG: href depends on the EType and duration
                            const QString ledValue = QString("%1%2%3")
                                                      .arg(LED)
                                                      .arg(colSpan > 1 ? QString::number(colSpan) : "")
                                                      .arg(isChord ? NO : LO);
                            if (pqs->isEmpty()) {
                                qts << SVG_USE << SVG_SPACE
                                    << formatInt(SVG_X, cellX, maxDigits, true)
                                    << SVG_Y << SVG_PERCENT // for multi-pitch
                                    << XLINK_HREF;

                                if (!isPages || idxPage == 0)
                                    qts << ledValue;

                                qts << SVG_QUOTE;
                            }

                            if (!isPages && isChord) // fully-formed data-cue="cue_id"
                                qts << SVG_CUE << cue_id << SVG_QUOTE;

                            // This ChordRest's pitch
                            const int p = (isChord
                                         ? static_cast<Chord*>(crData)->notes()[0]->pitch()
                                         : MIDI_REST);  // MIDI note values are 0-127

                            // Pitch for this cell
                            pil = (*pitches[idxCol])[r];
                            if (pil == 0) {
                                pil = new IntList;
                                (*pitches[idxCol])[r] = pil;
                            }
                            while (pil->size() < idxPage)
                                pil->append(MIDI_EMPTY);
                            if (pil->size() == idxPage)
                                pil->append(p);

                            if (isPages) {
                                if (isChord) { // rests don't get highlight cues
                                    // cue_id string for this cell
                                    pqs = (*dataCues[idxCol])[r];
                                    if (pqs == 0) {
                                        pqs = new QString;
                                        (*dataCues[idxCol])[r] = pqs;
                                    }
                                    qts.setString(pqs);
                                    if (pqs->isEmpty())
                                        qts << SVG_CUE;
                                    else
                                        qts << SVG_COMMA;
                                    qts << cue_id;
                                }
                                // LED value for page cues
                                spl = (*leds[idxCol])[r];
                                if (spl == 0) {
                                    spl = new StrPtrList;
                                    (*leds[idxCol])[r] = spl;
                                }
                                while (spl->size() <= idxPage) {
                                    pqs = new QString(SVG_HASH);
                                    if (spl->size() == idxPage)
                                        pqs->append(ledValue);
                                    spl->append(pqs);
                                }
                            }

                            if (colSpan > 1) // additional, non-grid cue_id
                                tableCues.append(cue_id);

                            if (!isPages)    // close the <use> element
                                qts << SVG_ELEMENT_END << endl;

                        } // else: SVG
                    } // else: r != idxGrid

                    cellY += cellHeight; // Move to the next row/staff

                } // for (r < nStaves)

                // Append new vectors (columns) to the list (grid)
                if (!isPages || idxCol == grid.size())
                    grid.append(spv);

                if (isPages)
                    idxCol++;

                height = cellY + cellHeight; // Extra row for title/buttons
                cellY = 0;
                cellX += cellWidth;

            } // if (crGrid->type() == EType::CHORD) - it's a live grid column

            if (isPageStart) {
                isPageStart = false;   // page start is always on measure start
                pageIDs.append(page_id); // this page's cue_id
            }

        } // for (segments within this measure)

        if (m->repeatEnd()) {                                                  /// TABLE END ///
            // This measure is the end of the pattern/table, deal with it:
            if (isHTML) {
                // Stream the <col> elements, instrument names column first
                tableStream << HTML_COL_BEGIN << SVG_GT  << endl;
                for (QStringList::iterator i  = tableCues.begin();
                                           i != tableCues.end();
                                         ++i)
                    tableStream << HTML_COL_BEGIN << SVG_CUE << *i
                                << SVG_QUOTE      << SVG_GT  << endl;

                // Stream the <tr>, <th>, and <td> elements: by row r, by col c
                for (int r = 0; r < nStaves; r++) {
                    bool isRowStarted = false;
                    for (int c = 0; c < grid.size(); c++) {
                        if (grid[c]->value(r) != 0) {
                            if (!isRowStarted) {
                                // Start the row and add the instrument name cell
                                tableStream << HTML_TR_BEGIN << SVG_GT << SVG_SPACE
                                            << HTML_TD_BEGIN << SVG_CLASS;
                                if (r != idxGrid)
                                    tableStream << CLASS_INSTRUMENT << SVG_QUOTE << SVG_GT
                                                << score->staff(r)->part()->longName(startOffset);
                                else
                                    tableStream << CLASS_TITLE      << SVG_QUOTE << SVG_GT
                                                << tableTitle;

                                tableStream << HTML_TD_END << SVG_SPACE;

                                isRowStarted = true;
                            }
                            tableStream << *(grid[c]->value(r)) << SVG_SPACE;
                        }
                    }
                    if(isRowStarted)
                        tableStream << HTML_TR_END << endl;
                }

                // </table>\n
                tableStream << HTML_TABLE_END << endl << endl;

            } // if (isHtml)
            else { // SVG = One file per table
                fnTable = QString("%1%2%3").arg(fnRoot).arg(SVG_DASH)
                                           .arg(tableTitle);
                tableFile.setFileName(QString("%1%2").arg(fnTable).arg(EXT_SVG));
                tableFile.open(QIODevice::WriteOnly | QIODevice::Text);  // TODO: check for failure here!!!
                tableStream.setDevice(&tableFile);

                // Stream the SVG header elements CSS, <svg>, <title>, <desc>:
                tableStream
                    // CSS Stylesheet
                    << XML_STYLEDRUMS
                    // <svg>
                    << SVG_BEGIN
                       << XML_NAMESPACE << XML_XLINK << SVG_4SPACES
                       << SVG_VIEW_BOX  << SVG_ZERO  << SVG_SPACE
                                        << SVG_ZERO  << SVG_SPACE
                                        << cellX     << SVG_SPACE
                                        << height    << SVG_QUOTE
                       << SVG_WIDTH     << cellX     << SVG_QUOTE
                       << SVG_HEIGHT    << height    << SVG_QUOTE
                                                           << endl << SVG_4SPACES
                       << SVG_PRESERVE_XYMIN_SLICE         << endl << SVG_4SPACES
                       << SVG_POINTER_EVENTS << SVG_CURSOR << endl << SVG_4SPACES
                       << SVG_CLASS << SMAWS << SVG_QUOTE  << SVG_ONLOAD
                    << SVG_GT << endl
                    // <title>
                    << SVG_TITLE_BEGIN << score->title() << SVG_TITLE_END << endl
                    // <desc>
                    << SVG_DESC_BEGIN  << smawsDesc()    << SVG_DESC_END
                << endl;

                // Import the <defs>
                QFile qf;
                qf.setFileName(QString("%1/%2").arg(qfi->path()).arg(FILE_DRUM_DEFS));
                qf.open(QIODevice::ReadOnly | QIODevice::Text);  // TODO: check for failure here!!!
                qts.setDevice(&qf);
                tableStream << endl << qts.readAll() << endl;

                // The background rects (pattern + gradient in one fill == not)
                tableStream << SVG_RECT
                            << SVG_X << SVG_QUOTE   << SVG_ZERO << SVG_QUOTE
                            << SVG_Y << SVG_QUOTE   << SVG_ZERO << SVG_QUOTE
                            << SVG_WIDTH            << cellX    << SVG_QUOTE
                            << SVG_HEIGHT           << height   << SVG_QUOTE
                            << SVG_FILL_URL         << "gradBg" << SVG_RPAREN_QUOTE
                            << SVG_ELEMENT_END      << endl
                            << SVG_RECT
                            << SVG_X << SVG_QUOTE   << SVG_ZERO << SVG_QUOTE
                            << SVG_Y << SVG_QUOTE   << SVG_ZERO << SVG_QUOTE
                            << SVG_WIDTH            << cellX    << SVG_QUOTE
                            << SVG_HEIGHT           << height   << SVG_QUOTE
                            << SVG_FILL_URL         << "pattBg" << SVG_RPAREN_QUOTE
                            << SVG_CLASS            << "background"    << SVG_QUOTE
                            << SVG_ELEMENT_END      << endl << endl;

                // This is just more convenient - now it's page count
                if (isPages)
                    idxPage++;

                // Stream the barLines (if they exist
                for (int b = 0; b < barLines.size(); b++) {
                    tableStream << *barLines[b];
                    if (idxPage > 1) { // are there page cues for this barline?
                        bool hasPageCues = false;
                        if (pageBars[b]->size() < idxPage)     // missing pages
                            hasPageCues = true;
                        else {
                            const int x = (*pageBars[b])[0];   // initial x
                            for (int p = 1; p < idxPage; p++) {
                                if ((*pageBars[b])[p] != x) {  // diff x-coords
                                    hasPageCues = true;
                                    break;
                                }
                            }
                        }
                        if (hasPageCues) { // page cues required
                            tableStream << SVG_CUE;
                            for (int p = 0; p < idxPage; p++) {
                                if (p > 0)
                                    tableStream << SVG_COMMA;
                                tableStream << pageIDs[p] << SVG_SEMICOLON;
                                if (p < pageBars[b]->size())
                                    tableStream << (*pageBars[b])[p];
                                else
                                    tableStream << -100;  // -1 isn't far enough off the canvas
                            }
                            tableStream << SVG_QUOTE;
                        }
                        tableStream << SVG_ELEMENT_END << endl;
                    }
                }
                tableStream << endl;

                // Stream the beatLines (beat and barline loops could be consolidated in a function)
                for (int b = 0; b < beatLines.size(); b++) {
                    tableStream << *beatLines[b];
                    if (idxPage > 1) { // are there page cues for this beatline?
                        bool hasPageCues = false;
                        if (pageBeats[b]->size() < idxPage)     // missing pages
                            hasPageCues = true;
                        else {
                            const int x = (*pageBeats[b])[0];   // initial x
                            for (int p = 1; p < idxPage; p++) {
                                if ((*pageBeats[b])[p] != x) {  // diff x-coords
                                    hasPageCues = true;
                                    break;
                                }
                            }
                        }
                        if (hasPageCues) { // page cues required
                            tableStream << SVG_CUE;
                            for (int p = 0; p < idxPage; p++) {
                                if (p > 0)
                                    tableStream << SVG_COMMA;
                                tableStream << pageIDs[p] << SVG_SEMICOLON;
                                if (p < pageBeats[b]->size())
                                    tableStream << (*pageBeats[b])[p];
                                else
                                    tableStream << -100;  // -1 isn't far enough off the canvas
                            }
                            tableStream << SVG_QUOTE;
                        }
                        tableStream << SVG_ELEMENT_END << endl;
                    }
                }
                tableStream << endl;

                // Stream the instrument names (left-most column) - similar loop to bar/beatlines
                for (int r = 0; r < nStaves; r++) {
                    if (r != idxGrid && iNames[r] != 0) {
                        tableStream << *iNames[r];
                        if (isPages) {
                            bool changesName  = false;
                            pqs = (*pageNames[0])[r];
                            for (int p = 1; p < idxPage; p++) {
                                 if (*(*pageNames[p])[r] != *pqs) {
                                    changesName = true;
                                    break;
                                }
                            }
                            bool changesStyle = false;
                            pqs = (*pageStyles[0])[r];
                            for (int p = 1; p < idxPage; p++) {
                                if (*(*pageStyles[p])[r] != *pqs) {
                                    changesStyle = true;
                                    break;
                                }
                            }
                            if (changesName || changesStyle) { // page cues required
                                tableStream << SVG_CUE;
                                for (int p = 0; p < idxPage; p++) {
                                    if (p > 0)
                                        tableStream << SVG_COMMA;
                                    tableStream << pageIDs[p] << SVG_SEMICOLON;
                                    if (changesName)
                                        tableStream << *(*pageNames[p])[r];
                                    if (changesStyle)
                                        tableStream << SVG_SEMICOLON
                                                    << *(*pageStyles[p])[r];
                                }
                                tableStream << SVG_QUOTE;
                            }
                        }
                        // Stream the >content</text>
                        tableStream << SVG_GT
                                    << score->staff(r)->part()->longName(startOffset)
                                    << SVG_TEXT_END << endl;
                    }
                }
                tableStream << endl;

                const int colCount = grid.size(); // max # of columns per page
                if (isPages) {
                    // Stream the grid staff separately
                    int minCols = colCount;       // min # of columns per page
                    for (int p = 0; p < idxPage; p++) {
                        if (pageCols[p] < minCols)
                            minCols = pageCols[p];
                    }
                    for (int g = 0; g < colCount; g++) {
                        tableStream << *gridUse[g];
                        if (g >= minCols){ // grayed-out <use>s by page
                            for (int p = 0; p < idxPage; p++) {
                                tableStream << SVG_COMMA     << pageIDs[p]
                                            << SVG_SEMICOLON << SVG_HASH
                                            << "grid";
                                if (g < pageCols[p])
                                    tableStream << NO;
                                else
                                    tableStream << LO;
                            }
                        }
                        tableStream << SVG_QUOTE
                                    << SVG_ELEMENT_END  << endl
                                    << *gridText[g];

                        bool hasPageCues = (g >= minCols);
                        if (!hasPageCues) {
                            pqs = (*pageGridText[0])[g];
                            for (int p = 0; p < idxPage; p++) {
                                if (*(*pageGridText[p])[g] != *pqs) {
                                    hasPageCues = true;
                                    break;
                                }
                            }
                        }
                        if (hasPageCues) {
                            for (int p = 0; p < idxPage; p++) {
                                tableStream << SVG_COMMA << pageIDs[p] << SVG_SEMICOLON;
                                if (g < pageCols[p])
                                    tableStream << *(*pageGridText[p])[g];
                            }
                        }

                        tableStream << SVG_QUOTE << SVG_GT;
                        if (g < pageCols[0])
                            tableStream << *(*pageGridText[0])[g];
                        tableStream << SVG_TEXT_END  << endl;
                    }
                    tableStream << endl;

                    // ...on a side note - this needs termination:
                    pageCues += SVG_QUOTE;
                }

                // Handle variable pitch in the rows that have it
                RealVect intervals(nStaves, 0); // pitch vertical increment

                // Convert the pitch values to ordinal values within a row
                for (int r = 0; r < nStaves; r++) {
                    pil = new IntList;
                    for (int c = 0; c < colCount; c++) {
                        if ((*pitches[c])[r] != 0) {
                            pil->append(*(*pitches[c])[r]);
                        }
                    }
                    if (pil->size() == 0)
                        continue;
                    pil = new IntList(pil->toSet().toList());
                    std::sort(pil->begin(), pil->end());
                    while (pil->size() > 0 && pil->first() < 0)
                        pil->pop_front();  // remove rests/empties from the set
                    if (pil->size() > 1) {
                        intervals[r] = verticalSpace / (pil->size() - 1);
                        std::reverse(pil->begin(), pil->end()); // higher pitch = lower y-offset
                    }
                    pitchSet[r] = pil;
                }

                // Stream the cells by column by row (by page)
                for (int c = 0; c < grid.size(); c++) {
                    cellY = 0;
                    for (int r = 0; r < nStaves; r++) {
                        if ((*grid[c])[r] == 0 || (isPages && r == idxGrid)) {
                            if (isPages)
                                cellY += cellHeight;
                            continue;
                        }
                        int  pitch0;
                        qreal y = cellY;
                        const bool hasPitches = (pitchSet[r] != 0
                                              && pitchSet[r]->size() > 1);
                        pqs = (*grid[c])[r];
                        pil = (*pitches[c])[r];
                        if (hasPitches) {
                            pitch0 = (*pil)[0];
                            const int idx = pitchSet[r]->indexOf(pitch0);
                            y += (idx >= 0 ? intervals[r] * idx : restOffset);
                            pqs->replace(LED, MINI);
                        }
                        pqs->replace(QString("%1%2")    .arg(SVG_Y).arg(SVG_PERCENT),
                                     QString("%1%2%3%4").arg(SVG_Y).arg(SVG_QUOTE)
                                                        .arg(y)    .arg(SVG_QUOTE));
                        tableStream << *pqs;

                        if (isPages) {                        // Page Cues?
                            bool changesPitch  = false;
                            bool changesLED    = false;
                            const bool hasCues = ((*dataCues[c])[r] != 0);
                            if (hasCues)
                                tableStream << *(*dataCues[c])[r];

                            spl  = (*leds[c])[r];
                            if (spl != 0)
                                pqs  = (*spl)[0];
                            for (int p = 0; p < idxPage; p++) {
                                if (hasPitches && !changesPitch && (*pil)[p] != pitch0)
                                    changesPitch = true;
                                if (!changesLED && spl != 0
                                && ((*spl)[p]->size() == 1 || (*spl)[p] != *pqs))
                                    changesLED = true;
                                if (changesPitch && changesLED)
                                    break;
                            }

                            const bool hasPageCues = (changesPitch || changesLED);
                            if (hasPageCues) { // Page Cues
                                for (int p = 0; p < idxPage; p++) {
                                    if (p == 0 && !hasCues)
                                        tableStream << SVG_CUE;
                                    else
                                        tableStream << SVG_COMMA;
                                    tableStream << pageIDs[p] << SVG_SEMICOLON;

                                    if (changesLED) {
                                        if (spl->size() > p) {
                                            if (hasPitches)
                                                (*spl)[p]->replace(LED, MINI);
                                            tableStream << *(*spl)[p];
                                        }
                                        else
                                            tableStream << SVG_HASH;
                                    }

                                    if (changesPitch) {
                                        tableStream << SVG_SEMICOLON;
                                        const int pitch = (*pil)[p];
                                        if (pitch == MIDI_EMPTY)
                                            tableStream << -100;  // effectively invisible
                                        else if (pitch == MIDI_REST)
                                            tableStream << cellY + (hasPitches ? restOffset : 0);
                                        else
                                            tableStream << cellY +
                                                          (intervals[r] * pitchSet[r]->indexOf(pitch));
                                    }
                                }
                            }
                            if (hasCues || hasPageCues)
                                tableStream << SVG_QUOTE;
                            tableStream << SVG_ELEMENT_END << endl;
                        }
                        cellY += cellHeight;
                    }
                    tableStream << endl; // Separates each column/group-of-rows
                }

                // Import and vertically position the buttons/title.
                // This file includes the reference to the external javascript,
                // as well as the audio and vtt files.
                qf.setFileName(QString("%1/%2").arg(qfi->path()).arg(isPages ? FILE_PAGE_BUTTS
                                                                             : FILE_DRUM_BUTTS));
                qf.open(QIODevice::ReadOnly | QIODevice::Text);  // TODO: check for failure here!!!
                qts.setDevice(&qf);
                tableStream << qts.readAll().replace("%1", QString::number(height - 47))
                                            .replace("%2", QString::number(height - 10.5))
                                            .replace("%3", tableTitle)
                                            .replace("%4", qfi->completeBaseName())
                                            .replace("%5", pageCues) // if (isPages)
                                            .replace("%6", QString("%1")
                                                           .arg(idxPage, 2, 10,
                                                                QLatin1Char(SVG_ZERO)));
                // </svg>
                tableStream << SVG_END;

                // Write and close the SVG file for this table
                tableStream.flush();
                tableFile.close();

                // Write the VTT file for this table
                if (!saveVTT(score, fnTable, tableCues))
                    return false;

                // Reset this for the next time around
                cellX = iNameWidth;
            }

            // Reset for next table
            cellY     = 0;
            gridTicks = 0;
            grid.clear();
            gridUse.clear();
            gridText.clear();
            barLines.clear();
            beatLines.clear();
            tableCues.clear();
            pitches.clear();
            for (int r = 0; r < nStaves; r++) {
                iNames[r]   = 0;
                pitchSet[r] = 0;
            }
            if (isPages) {
                isPages  = false;
                pageTick = 0;
                idxPage  = 0;
                leds.clear();
                pageIDs.clear();
                dataCues.clear();
                pageCues.clear();
                pageCols.clear();
                pageBars.clear();
                pageBeats.clear();
                pageNames.clear();
                pageStyles.clear();
                pageGridText.clear();
            }
        } // if(Repeat::END)
        else {
            const int x = cellX * (isPages && idxPage > 0 ? -1 : 1);
            if (!isHTML
            && (!isPages || (idxBar == barLines.size() && m != mPageEnd))) {
                // End-of-Bar lines for the all but the last bar of the pattern.
                // <rect> because <line>s are funky with gradients.
                pqs = new QString;
                qts.setString(pqs);
                qts << SVG_RECT
                       << SVG_X << SVG_QUOTE << x - barRound       << SVG_QUOTE
                       << SVG_Y << SVG_QUOTE << barMargin - 2      << SVG_QUOTE
                       << SVG_WIDTH          << barWidth           << SVG_QUOTE
                       << SVG_HEIGHT         << height - cellHeight
                                              - barMargin - 2      << SVG_QUOTE
                       << SVG_RX             << barRound           << SVG_QUOTE
                       << SVG_RY             << barRound           << SVG_QUOTE
                       << SVG_CLASS          << "barLine"          << SVG_QUOTE;
                if (!isPages)
                    qts << SVG_ELEMENT_END   << endl;

                barLines.append(pqs);
            }
            if (isPages) {
                if (pageBars.size() == idxBar) {
                    pil = new IntList;
                    pageBars.append(pil);
                }
                while (pageBars[idxBar]->size() < idxPage)
                    pageBars[idxBar]->append(x); // This barline is initially invisible
                pageBars[idxBar]->append(cellX);
                idxBar++;
            }
        }
    } // for(measures)

    if (isHTML) { // Only one file, complete it, write it, and close it
        tableStream << HTML_BODY_END << endl << HTML_END << endl;
        tableStream.flush();
        tableFile.close();

        // Write the VTT file
        if (!saveVTT(score, fnRoot, tableCues))
            return false;

    }

    return true;
}

//
// 1 MAB file generator: saveMAB_MixTree()
//
bool MuseScore::saveMAB_MixTree(Score* score, QFileInfo* qfi)
{
    QMultiMap<QString, QString> mapMAB; // key = CueID, value = InstrumentName
    const char notChar = '!'; // used only once, but I deplore raw literals

    // Iterate by Staff, by ChordRest, collecting into mapMAB
    for (int t = 0, max = score->nstaves() * VOICES;
             t < max;
             t += VOICES)
    {
        // Staff index
        const int idx = t / VOICES;

        // These are smaller in SVG too
        const bool isPulse = score->staff(idx)->small();

        // 1 Intrument Name = comma-separated list of MixTree node names
        const QString iName = score->systems().first()->staff(idx)->instrumentNames.first()->xmlText();

        // The "not" (gray-out) version of the instrument name.
        // Each node name must be prefixed with the notChar in the cue text.
        QStringList notList = iName.split(SVG_COMMA);
        QString notName;
        QTextStream qts(&notName);
        for (QStringList::iterator i = notList.begin(); i != notList.end(); ++i) {
            if (i != notList.begin())
                qts << SVG_COMMA; // Comma-delimited, but not comma-terminated
            qts << notChar << *i;
        }

        int      startTick  = 0;
        bool     isPrevRest = true; // Is the previous element a rest?
        Measure* pm = 0;            // The previous measure
        Note*    note;

        // By measure by segment of type ChordRest
        for (Measure* m = score->firstMeasure();
                      m;
                      m = m->nextMeasureMM())
        {
            // Empty measure = all rests
            // Empty measures generate gray-out cues for the timeline rulers.
            if (m->isMeasureRest(idx)) {
                // If there is a highlight cue pending, finish it.
                // --Duplicates code from below, see: "Case: EType::Rest".--
                if (!isPulse && !isPrevRest && startTick != 0) {
                    isPrevRest = true;
                    mapMAB.insert(getCueID(startTick, m->tick()), iName);
                }

                // Empty measure following a non-empty measure. Start of
                // a possibly multi-measure rest.
                if (pm != 0 && !pm->isMeasureRest(idx))
                    startTick = m->tick();

                // Final measure is empty
                if (!m->nextMeasureMM())
                    mapMAB.insert(getCueID(startTick, m->tick() + m->ticks()), notName);
            }
            // Non-empty measures have highlight and pulse cues
            else {
                // Complete any pending gray-out cue
                if (pm != 0 && pm->isMeasureRest(idx))
                    mapMAB.insert(getCueID(startTick, m->tick()), notName);

                // Highlight and Pulse cues
                for (Segment* s = m->first(Segment::Type::ChordRest);
                              s;
                              s = s->next(Segment::Type::ChordRest))
                {
                    ChordRest* cr = s->cr(t);
                    if (cr == 0)
                        continue;
                    switch (cr->type()) {
                    case EType::CHORD :
                        if (isPulse || isPrevRest) {
                            isPrevRest = false;
                            startTick = cr->tick();
                        }
                        if (isPulse) {
                            note = static_cast<Chord*>(cr)->notes()[0];
                            while (note->tieFor() && note != note->tieFor()->endNote())
                                note = note->tieFor()->endNote();
                            cr = static_cast<ChordRest*>(note->parent());
                            mapMAB.insert(getCueID(startTick, cr->tick() + cr->actualTicks()), iName);
                            s = cr->segment(); // Updates the pointer used in the inner for loop!
                        }
                        break;
                    case EType::REST :
                        if (!isPulse && !isPrevRest && startTick != 0) {
                            isPrevRest = true;
                            mapMAB.insert(getCueID(startTick, cr->tick()), iName);
                        }
                        break;
                    default:
                        break; // This should never happen
                    }
                }
            }
            pm = m; // Remember the previous measure for the next iteration
        }
        // If the chord lasts until the end of the score
        if (!isPulse && !isPrevRest)
            mapMAB.insert(getCueID(startTick, score->lastSegment()->tick()), iName);
    }


    // Open a stream into the file
    QFile fileVTT;
    fileVTT.setFileName(qfi->filePath());
    fileVTT.open(QIODevice::WriteOnly | QIODevice::Text);  // TODO: check for failure here!!!
    QTextStream streamVTT(&fileVTT);

    // Stream the header
    streamVTT << VTT_HEADER;

    // Stream the cues, iterating by cue_id
    const TempoMap* tempos = score->tempomap();
    const QStringList keys = mapMAB.uniqueKeys();
    for (QStringList::const_iterator cue_id  = keys.cbegin();
                                     cue_id != keys.cend();
                                   ++cue_id)
    {
        const QStringList values = mapMAB.values(*cue_id); // QStringList::join()

        // Stream the cue: 0000000_1234567
        //                 00:00:00.000 --> 12:34:56.789
        //                 Instrument1,Instrument2,...,InstrumentN
        //                [this line intentionally left blank, per WebVTT spec]

        streamVTT << getVTTCueTwo(*cue_id, tempos);  // First two lines
        streamVTT << values.join(SVG_COMMA) << endl; // Instrument list
        streamVTT << endl;                           // Blank line
    }

    // Write and close the file
    streamVTT.flush();
    fileVTT.close();
    return true;
}

// End SVG / SMAWS / MAB
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//   createThumbnail
//---------------------------------------------------------

static QPixmap createThumbnail(const QString& name)
      {
      MasterScore* score = new MasterScore;
      Score::FileError error = readScore(score, name, true);
      if (error != Score::FileError::FILE_NO_ERROR)
            return QPixmap();
      score->doLayout();
      QImage pm = score->createThumbnail();
      delete score;
      return QPixmap::fromImage(pm);
      }

//---------------------------------------------------------
//   extractThumbnail
//---------------------------------------------------------

QPixmap MuseScore::extractThumbnail(const QString& name)
      {
      QPixmap pm; //  = icons[File_ICON].pixmap(QSize(100,140));
      if (!name.endsWith(".mscz"))
            return createThumbnail(name);
      MQZipReader uz(name);
      if (!uz.exists()) {
            qDebug("extractThumbnail: <%s> not found", qPrintable(name));
            return pm;
            }
      QByteArray ba = uz.fileData("Thumbnails/thumbnail.png");
      if (ba.isEmpty())
            return createThumbnail(name);
      pm.loadFromData(ba, "PNG");
      return pm;
      }

}

